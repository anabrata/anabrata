<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>A4 Portrait • Photos 4×3 cm • 6 per row • Made by ANABRATA</title>
<meta name="color-scheme" content="light dark" />
<style>
  :root{
    --green:#10b981; --yellow:#fde047; --blue:#3b82f6;
    --card:#ffffffee; --text:#0b1020; --muted:#4b5563; --ring:rgba(0,0,0,.12);
    --grad: linear-gradient(135deg, var(--green), var(--blue), var(--yellow));
  }
  body{
    margin:0; font-family:system-ui,Segoe UI,Roboto,Arial,sans-serif; color:var(--text);
    background:
      radial-gradient(1200px 800px at 10% 10%, rgba(16,185,129,.25), transparent 60%),
      radial-gradient(1200px 800px at 90% 20%, rgba(59,130,246,.25), transparent 60%),
      radial-gradient(1200px 800px at 50% 100%, rgba(253,224,71,.25), transparent 60%),
      linear-gradient(120deg, #e8fdf6, #eef4ff 40%, #fffbe6 80%, #ffffff);
    background-size:140% 140%; animation:bgShift 18s ease-in-out infinite alternate;
  }
  @keyframes bgShift{
    0%{ background-position:0% 0%, 100% 0%, 50% 100%, 0% 0% }
    100%{ background-position:50% 30%, 50% 20%, 60% 70%, 100% 100% }
  }
  .wrap{ width:min(1120px,94%); margin:0 auto; }

  header.hero{ min-height:34vh; display:grid; place-items:center; text-align:center; padding: clamp(1.6rem,6vw,3rem) 0 1rem; }
  .welcome{
    font-weight:900; letter-spacing:.06em; line-height:1.1;
    background:linear-gradient(90deg, var(--green), var(--blue), var(--yellow), var(--green));
    -webkit-background-clip:text; background-clip:text; color:transparent;
    background-size:200% 100%;
    font-size: clamp(1.3rem, 4.2vw, 2.5rem);
    animation: fadeInOut 8s ease-in-out infinite, hue 14s linear infinite;
  }
  @keyframes hue{ 0%{background-position:0% 50%} 100%{background-position:200% 50%} }
  @keyframes fadeInOut{ 0%{opacity:0} 18%{opacity:1} 82%{opacity:1} 100%{opacity:0} }
  .byline{ margin-top:.5rem; font-weight:800; color:#0b1020; display:inline-block; padding:.35rem .7rem; border-radius:.7rem;
           background:linear-gradient(90deg, rgba(16,185,129,.18), rgba(59,130,246,.18), rgba(253,224,71,.18));
           box-shadow:0 6px 22px rgba(16,185,129,.14), 0 4px 16px rgba(59,130,246,.12) }

  .card{ background:var(--card); backdrop-filter:blur(6px); border:1px solid var(--ring); border-radius:14px; padding:1rem; box-shadow:0 10px 28px rgba(0,0,0,.08) }
  .row{ display:flex; gap:.8rem; align-items:center; flex-wrap:wrap }
  .btn{ background:var(--grad); color:#073b2b; border:0; padding:.74rem 1.05rem; border-radius:.8rem; font-weight:900; cursor:pointer;
        box-shadow:0 6px 18px rgba(16,185,129,.22), 0 3px 12px rgba(59,130,246,.14) }
  .btn.ghost{ background:linear-gradient(135deg, rgba(16,185,129,.12), rgba(59,130,246,.12)); color:#0b1020; border:1px solid var(--ring) }

  .field{ position:relative; display:flex; align-items:center; gap:.5rem; background:#f8fafc;
          border:1px solid #e5e7eb; border-radius:.8rem; padding:.45rem .65rem }
  .field input, .field label{ border:0; background:transparent; outline:none; font:inherit; color:inherit; padding:.35rem .2rem }

  .dropzone{ position:relative; display:grid; place-items:center; text-align:center; padding:1.1rem; border-radius:1rem;
             border:2px dashed #cbd5e1; background:linear-gradient(135deg, rgba(16,185,129,.08), rgba(59,130,246,.08), rgba(253,224,71,.08)) }
  #file{ display:none }
  .thumb{ margin-top:.6rem; display:flex; gap:.6rem; align-items:center; justify-content:center }
  .thumb img{ width:84px; height:63px; object-fit:cover; border-radius:.5rem; border:1px solid #e5e7eb; background:#fff } /* 4×3 preview */

  .grid{ display:grid; gap:1rem; grid-template-columns:1.2fr .8fr; align-items:start; margin:1rem 0 2rem }
  @media (max-width:980px){ .grid{ grid-template-columns:1fr } }
  canvas{ width:100%; background:#fff; border-radius:10px; border:1px solid #e5e7eb }
  .muted{ color:#4b5563 }
  .info{ text-align:center; color:#111827; opacity:.9; margin:1.2rem 0 2.2rem }
</style>
</head>
<body>
  <header class="hero">
    <div class="wrap">
      <div class="welcome">WELCOME IN THE WORLD OF PHOTOS</div>
      <div class="byline">Made by ANABRATA</div>
    </div>
  </header>

  <main class="wrap">
    <section class="card">
      <div class="row" style="justify-content:space-between">
        <div class="row">
          <span class="muted">A4 portrait: 210 × 297 mm • Photo: 4 × 3 cm • 6 columns (auto‑rotate to fit)</span>
        </div>
      </div>

      <div class="row" style="margin-top:.7rem">
        <div class="dropzone">
          <div>
            <div style="font-weight:800">Choose one photo</div>
            <div class="muted" style="font-size:.95rem">Default copies: 6. Tiles print exactly 4 × 3 cm.</div>
            <div class="row" style="justify-content:center; margin-top:.6rem">
              <button class="btn" id="chooseBtn" type="button">Choose photo</button>
              <button class="btn ghost" id="arrange" type="button">Arrange → PDF</button>
              <a id="downloadPdf" class="btn ghost" download="photos_a4_portrait_4x3cm_6cols.pdf" href="#" aria-disabled="true">Download PDF</a>
            </div>
            <div class="thumb" id="thumb" style="display:none">
              <img id="thumbImg" alt="Selected photo preview" />
              <span class="muted" id="fileNote"></span>
            </div>
          </div>
          <input id="file" type="file" accept="image/*" />
        </div>
      </div>

      <div class="row" style="margin-top:.7rem">
        <div class="field"><span>Number of photos</span><input id="copies" type="number" value="6" min="1" step="1"></div>
        <div class="field"><span>Gap (mm)</span><input id="gap" type="number" value="2" step="0.5" min="0"></div>
        <label class="field" style="gap:.5rem"><input id="centerGrid" type="checkbox" checked> <span>Center grid</span></label>
        <label class="field" style="gap:.5rem"><input id="autoRotate" type="checkbox" checked> <span>Auto‑rotate 4×3 ↔ 3×4</span></label>
      </div>

      <div style="margin-top:.6rem">
        <progress id="prog" value="0" max="100" hidden></progress>
        <div id="note" class="muted" style="margin-top:.35rem"></div>
      </div>
    </section>

    <section class="grid">
      <div class="card">
        <h3 style="margin:.2rem 0 .8rem">Preview (scaled)</h3>
        <!-- A4 portrait preview -->
        <canvas id="preview" width="840" height="1188" aria-label="Preview canvas"></canvas>
        <p class="muted" style="margin:.5rem 0 0">Print at 100% scale (no “Fit to page”). Each tile = 40 × 30 mm.</p>
      </div>
      <div class="card">
        <h3 style="margin:.2rem 0 .8rem">How 6 columns work on portrait</h3>
        <ul class="muted" style="margin:.2rem 0 0; padding-left:1rem; list-style:disc">
          <li>Margins are 10 mm on all sides to allow 6 across.</li>
          <li>If needed, tiles auto‑rotate to 3×4 (30 mm wide) so 6 fit within portrait width.</li>
          <li>Horizontal gap is clamped so 6 columns always fit; rows flow to new pages.</li>
        </ul>
      </div>
    </section>

    <div class="info">© <span id="year"></span> Made by ANABRATA</div>
  </main>

  <script src="https://cdn.jsdelivr.net/npm/jspdf@2.5.1/dist/jspdf.umd.min.js"></script>

  <script>
  // Year
  document.getElementById('year').textContent = new Date().getFullYear();

  // A4 portrait
  const PAGE_W_MM = 210, PAGE_H_MM = 297;
  const MARGIN_MM = 10;                 // 1 cm margins to allow 6 columns
  // Base tile size is 4×3 cm (40×30). We can swap to 3×4 (30×40) if autoRotate is ON.
  const TILE_W_4x3 = 40, TILE_H_4x3 = 30;
  const TILE_W_3x4 = 30, TILE_H_3x4 = 40;
  const COLS = 6;

  // Elements
  const $ = id => document.getElementById(id);
  const fileEl = $('file');
  const chooseBtn = $('chooseBtn');
  const thumb = $('thumb');
  const thumbImg = $('thumbImg');
  const fileNote = $('fileNote');
  const copiesInput = $('copies');
  const gapInput = $('gap');
  const centerGridInput = $('centerGrid');
  const autoRotateInput = $('autoRotate');
  const arrangeBtn = $('arrange');
  const downloadPdf = $('downloadPdf');
  const note = $('note');
  const prog = $('prog');
  const canvas = $('preview');
  const ctx = canvas.getContext('2d');

  chooseBtn.addEventListener('click', () => fileEl.click());
  fileEl.addEventListener('change', () => {
    if (fileEl.files && fileEl.files[0]){
      const f = fileEl.files[0];
      fileNote.textContent = f.name;
      thumbImg.src = URL.createObjectURL(f);
      thumb.style.display = '';
    } else { thumb.style.display = 'none'; thumbImg.removeAttribute('src'); fileNote.textContent = ''; }
  });

  // Utilities
  function blobToImage(blob){
    return new Promise((res, rej) => {
      const url = URL.createObjectURL(blob);
      const img = new Image();
      img.onload = () => { URL.revokeObjectURL(url); res(img); };
      img.onerror = rej;
      img.src = url;
    });
  }
  // Center-crop to fill destination
  function drawImageCover(ctx, img, dx, dy, dW, dH){
    const iw = img.naturalWidth || img.width;
    const ih = img.naturalHeight || img.height;
    const ir = iw / ih, dr = dW / dH;
    let sx, sy, sw, sh;
    if (ir > dr){ sh = ih; sw = ih * dr; sx = (iw - sw)/2; sy = 0; }
    else       { sw = iw; sh = iw / dr; sx = 0; sy = (ih - sh)/2; }
    ctx.drawImage(img, sx, sy, sw, sh, dx, dy, dW, dH);
  }

  // Pick tile orientation. If autoRotate, choose the one that permits 6 across with non-negative gap.
  function pickTileSize(userGap){
    const availW = PAGE_W_MM - 2*MARGIN_MM;
    // For 4×3 orientation
    const maxGX_4x3 = (availW - COLS*TILE_W_4x3) / (COLS - 1);
    // For 3×4 orientation
    const maxGX_3x4 = (availW - COLS*TILE_W_3x4) / (COLS - 1);

    if (!autoRotateInput.checked){
      const use3x4 = TILE_W_4x3 > availW / COLS; // if 4×3 can't fit even without gaps, fall back to 3×4
      const tw = use3x4 ? TILE_W_3x4 : TILE_W_4x3;
      const th = use3x4 ? TILE_H_3x4 : TILE_H_4x3;
      const maxGX = use3x4 ? maxGX_3x4 : maxGX_4x3;
      return { tw, th, maxGX: Math.max(0, maxGX) };
    }

    // Prefer orientation that can accommodate the user's gap (or largest max gap)
    const canA = maxGX_4x3 >= 0;
    const canB = maxGX_3x4 >= 0;

    if (canA && canB){
      // Choose the one whose max gap is closer to userGap (allows larger spacing)
      if (Math.abs(maxGX_4x3 - userGap) <= Math.abs(maxGX_3x4 - userGap)){
        return { tw: TILE_W_4x3, th: TILE_H_4x3, maxGX: Math.max(0, maxGX_4x3) };
      } else {
        return { tw: TILE_W_3x4, th: TILE_H_3x4, maxGX: Math.max(0, maxGX_3x4) };
      }
    } else if (canA){
      return { tw: TILE_W_4x3, th: TILE_H_4x3, maxGX: Math.max(0, maxGX_4x3) };
    } else {
      return { tw: TILE_W_3x4, th: TILE_H_3x4, maxGX: Math.max(0, maxGX_3x4) };
    }
  }

  function rowsPerPage(tileH, gapY){
    const availH = PAGE_H_MM - 2*MARGIN_MM;
    return Math.max(1, Math.floor((availH + gapY) / (tileH + gapY)));
  }
  function solveGapYForRows(tileH, rows){
    if (rows <= 1) return 0;
    const availH = PAGE_H_MM - 2*MARGIN_MM;
    return Math.max(0, (availH - rows*tileH) / (rows - 1));
  }

  function planLayout(userGap, copies){
    const { tw, th, maxGX } = pickTileSize(userGap);
    const gapX = Math.min(userGap, maxGX);
    const rowsNeeded = Math.ceil(copies / COLS);

    // Try with user vertical gap first
    let gapY = userGap;
    let rpp = rowsPerPage(th, gapY);

    if (rowsNeeded > rpp){
      // Try shrinking vertical gap to fit rowsNeeded
      gapY = solveGapYForRows(th, rowsNeeded);
      rpp = rowsPerPage(th, gapY);
    }

    const paginate = rowsNeeded > rpp;
    const rowsFirstPage = paginate ? rpp : rowsNeeded;
    const capacityFirst = COLS * rowsFirstPage;

    return { tw, th, gapX, gapY, rowsFirstPage, capacityFirst, paginate, rpp };
  }

  // Preview (first page)
  async function previewLayout(img, copies, userGap, center){
    const p = planLayout(userGap, copies);
    const { tw, th, gapX, gapY, rowsFirstPage, capacityFirst } = p;

    const pxPerMM = canvas.width / PAGE_W_MM;
    const pageWpx = Math.round(PAGE_W_MM * pxPerMM);
    const pageHpx = Math.round(PAGE_H_MM * pxPerMM);
    const tileWpx = Math.round(tw * pxPerMM);
    const tileHpx = Math.round(th * pxPerMM);
    const gapXpx  = Math.round(gapX * pxPerMM);
    const gapYpx  = Math.round(gapY * pxPerMM);

    const gridWmm = COLS*tw + (COLS-1)*gapX;
    const gridHmm = rowsFirstPage*th + (rowsFirstPage-1)*gapY;

    const ox = center ? Math.round((PAGE_W_MM - gridWmm) * pxPerMM / 2) : Math.round(MARGIN_MM * pxPerMM);
    const oy = center ? Math.round((PAGE_H_MM - gridHmm) * pxPerMM / 2) : Math.round(MARGIN_MM * pxPerMM);

    // Page + margins
    ctx.fillStyle = '#ffffff'; ctx.fillRect(0,0,pageWpx,pageHpx);
    const marginPx = Math.round(MARGIN_MM * pxPerMM);
    ctx.strokeStyle = '#d1d5db'; ctx.lineWidth = 1;
    ctx.strokeRect(marginPx + .5, marginPx + .5, pageWpx - 2*marginPx - 1, pageHpx - 2*marginPx - 1);

    let i = 0, place = Math.min(copies, capacityFirst);
    for (let r=0; r<rowsFirstPage && i<place; r++){
      for (let c=0; c<COLS && i<place; c++){
        const x = ox + c * (tileWpx + gapXpx);
        const y = oy + r * (tileHpx + gapYpx);
        drawImageCover(ctx, img, x, y, tileWpx, tileHpx);
        i++;
      }
    }

    // Notes
    const { maxGX } = pickTileSize(userGap);
    if (userGap > maxGX){
      note.textContent = `Horizontal gap reduced to ${gapX.toFixed(2)} mm to keep 6 columns.`;
    } else {
      note.textContent = '';
    }
    return p;
  }

  // Build PDF (multi-page if needed)
  async function buildPdf(img, copies, userGap, center){
    const { jsPDF } = window.jspdf;
    const p = planLayout(userGap, copies);
    const { tw, th, gapX, gapY, rpp } = p;

    const doc = new jsPDF({ unit:'mm', format:[PAGE_W_MM, PAGE_H_MM] }); // portrait

    // Prepare one high‑quality tile
    const pxPerMM = 10; // ~254 dpi
    const off = document.createElement('canvas');
    off.width  = Math.round(tw * pxPerMM);
    off.height = Math.round(th * pxPerMM);
    const oc = off.getContext('2d');
    oc.fillStyle = '#ffffff'; oc.fillRect(0,0,off.width,off.height);
    drawImageCover(oc, img, 0, 0, off.width, off.height);
    const tileURL = off.toDataURL('image/jpeg', 0.92);

    function drawPage(startIndex){
      const rowsOnPage = rpp;
      const gridWmm = COLS*tw + (COLS-1)*gapX;
      const gridHmm = rowsOnPage*th + (rowsOnPage-1)*gapY;
      const ox = center ? Math.max(0, (PAGE_W_MM - gridWmm) / 2) : MARGIN_MM;
      const oy = center ? Math.max(0, (PAGE_H_MM - gridHmm) / 2) : MARGIN_MM;

      let idx = startIndex;
      for (let r=0; r<rowsOnPage && idx<copies; r++){
        for (let c=0; c<COLS && idx<copies; c++){
          const x = ox + c * (tw + gapX);
          const y = oy + r * (th + gapY);
          doc.addImage(tileURL, 'JPEG', x, y, tw, th);
          idx++;
        }
      }
      return idx;
    }

    let index = 0;
    while (index < copies){
      index = drawPage(index);
      if (index < copies) doc.addPage([PAGE_W_MM, PAGE_H_MM], 'portrait');
    }
    return doc.output('blob');
  }

  // Arrange → PDF
  $('arrange').onclick = async () => {
    try{
      note.textContent = "Reading photo…";
      prog.hidden = false; prog.value = 10;

      if (!fileEl.files || !fileEl.files[0]){
        note.textContent = "No photo selected. Click ‘Choose photo’.";
        prog.hidden = true; return;
      }
      const img = await blobToImage(fileEl.files[0]);

      const copies = Math.max(1, parseInt(copiesInput.value || '6', 10));
      const userGap = Math.max(0, parseFloat(gapInput.value || '0'));
      const center = !!centerGridInput.checked;

      prog.value = 35; note.textContent = "Arranging preview…";
      await previewLayout(img, copies, userGap, center);

      prog.value = 60; note.textContent = "Building PDF…";
      const blob = await buildPdf(img, copies, userGap, center);

      const url = URL.createObjectURL(blob);
      downloadPdf.href = url;
      downloadPdf.setAttribute('aria-disabled','false');

      prog.value = 100; note.textContent = "PDF ready. Print at 100% scale (no fit).";
      setTimeout(() => prog.hidden = true, 400);
    } catch(e){
      console.error(e);
      note.textContent = "Error: " + e.message;
      prog.hidden = true;
    }
  };
  </script>
</body>
</html>
