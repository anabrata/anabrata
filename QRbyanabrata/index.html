<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>QR Arranger (A4 only) • Made by ANABRATA</title>
<meta name="color-scheme" content="light dark" />
<style>
  :root{
    --green:#10b981; --yellow:#fde047; --blue:#3b82f6; --white:#ffffff;
    --card:#ffffffee; --text:#0b1020; --muted:#4b5563; --ring:rgba(0,0,0,.12);
    --grad: linear-gradient(135deg, var(--green), var(--blue), var(--yellow));
    --field-bg:#f8fafc; --field-bd:#e5e7eb; --field-focus:#93c5fd;
  }
  /* Animated multi-color background */
  body{
    margin:0; font-family:system-ui,Segoe UI,Roboto,Arial,sans-serif; color:var(--text);
    background:
      radial-gradient(1200px 800px at 10% 10%, rgba(16,185,129,.25), transparent 60%),
      radial-gradient(1200px 800px at 90% 20%, rgba(59,130,246,.25), transparent 60%),
      radial-gradient(1200px 800px at 50% 100%, rgba(253,224,71,.25), transparent 60%),
      linear-gradient(120deg, #e8fdf6, #eef4ff 40%, #fffbe6 80%, #ffffff);
    background-size:140% 140%; animation:bgShift 18s ease-in-out infinite alternate;
  }
  @keyframes bgShift{
    0%{ background-position:0% 0%, 100% 0%, 50% 100%, 0% 0% }
    100%{ background-position:50% 30%, 50% 20%, 60% 70%, 100% 100% }
  }
  .wrap{ width:min(1120px,94%); margin:0 auto; }

  /* Hero with slower FADE welcome */
  header.hero{ min-height:42vh; display:grid; place-items:center; text-align:center; padding: clamp(2rem,6vw,4rem) 0 1rem; }
  .welcome{
    font-weight:900; letter-spacing:.06em; line-height:1.1;
    background:linear-gradient(90deg, var(--green), var(--blue), var(--yellow), var(--green));
    -webkit-background-clip:text; background-clip:text; color:transparent;
    background-size:200% 100%;
    font-size: clamp(1.4rem, 4.5vw, 2.8rem);
    animation: fadeInOut 8s ease-in-out infinite, hue 14s linear infinite; /* slower now */
  }
  @keyframes hue{ 0%{background-position:0% 50%} 100%{background-position:200% 50%} }
  @keyframes fadeInOut{
    0%   { opacity: 0 }
    18%  { opacity: 1 }
    82%  { opacity: 1 }
    100% { opacity: 0 }
  }
  .byline{
    margin-top:.6rem; font-weight:800; color:#0b1020; display:inline-block; padding:.4rem .8rem; border-radius:.7rem;
    background:linear-gradient(90deg, rgba(16,185,129,.18), rgba(59,130,246,.18), rgba(253,224,71,.18));
    box-shadow:0 6px 22px rgba(16,185,129,.14), 0 4px 16px rgba(59,130,246,.12);
  }

  /* Cards and UI */
  .card{ background:var(--card); backdrop-filter:blur(6px); border:1px solid var(--ring); border-radius:14px; padding:1rem; box-shadow:0 10px 28px rgba(0,0,0,.08) }
  .pill{ display:inline-block; padding:.28rem .6rem; border:1px solid var(--ring); border-radius:999px; font-size:.85rem; color:var(--muted);
         background: linear-gradient(135deg, rgba(16,185,129,.08), rgba(59,130,246,.08), rgba(253,224,71,.08)); }
  .row{ display:flex; gap:.8rem; align-items:center; flex-wrap:wrap }
  .controls{ display:grid; gap:1rem; grid-template-columns:1fr }

  .btn{
    background:var(--grad); color:#073b2b; border:0; padding:.76rem 1.05rem; border-radius:.8rem; font-weight:900; cursor:pointer;
    box-shadow:0 6px 18px rgba(16,185,129,.22), 0 3px 12px rgba(59,130,246,.14); transition:transform .12s ease, filter .2s ease;
  }
  .btn:hover{ transform:translateY(-1px); filter:brightness(1.05) }
  .btn.ghost{ background:linear-gradient(135deg, rgba(16,185,129,.12), rgba(59,130,246,.12)); color:#0b1020; border:1px solid var(--ring) }
  .muted{ color:var(--muted) }
  progress{ width:100% }

  /* Fancy fields */
  .field{ position:relative; display:flex; align-items:center; gap:.5rem; background:var(--field-bg);
          border:1px solid var(--field-bd); border-radius:.8rem; padding:.45rem .65rem }
  .field:focus-within{ outline:2px solid var(--field-focus); outline-offset:2px; border-color:transparent; background:#fff }
  .field input[type="number"], .field input[type="text"]{
    border:0; background:transparent; outline:none; font:inherit; color:inherit; padding:.35rem .2rem; min-width:6ch
  }

  /* Dropzone (fix: input no longer overlays buttons) */
  .dropzone{
    position:relative; display:grid; place-items:center; text-align:center; padding:1.2rem; border-radius:1rem;
    border:2px dashed #cbd5e1; background:linear-gradient(135deg, rgba(16,185,129,.08), rgba(59,130,246,.08), rgba(253,224,71,.08));
    transition:border-color .2s, background .2s;
  }
  .dropzone.drag{ border-color:#60a5fa; background:linear-gradient(135deg, rgba(16,185,129,.12), rgba(59,130,246,.12), rgba(253,224,71,.12)); }
  .dz-title{ font-weight:800 }
  .dz-sub{ color:var(--muted); font-size:.95rem }
  .dz-actions{ margin-top:.7rem; display:flex; gap:.6rem; justify-content:center; flex-wrap:wrap }
  #files{ display:none } /* input is hidden; chooseBtn triggers it */

  /* Layout */
  .grid{ display:grid; gap:1rem; grid-template-columns:1.1fr .9fr; align-items:start; margin:1rem 0 2rem }
  @media (max-width: 980px){ .grid{ grid-template-columns:1fr } }

  canvas{ width:100%; background:#fff; border-radius:10px; border:1px solid #e5e7eb }

  .info{ margin:1.2rem 0 2.2rem; text-align:center; color:#111827; opacity:.9 }
</style>
</head>
<body>
  <header class="hero">
    <div class="wrap">
      <div class="welcome" id="welcomeText">WELCOME TO THE WORLD OF QR CODEs</div>
      <div class="byline">Made by ANABRATA</div>
    </div>
  </header>

  <main class="wrap">
    <section class="card">
      <div class="row" style="justify-content:space-between">
        <div class="row">
          <span class="pill">Page: A4 (210 × 297 mm)</span>
          <span class="pill">Margins: 20 mm each side</span>
        </div>
      </div>

      <div class="controls">
        <!-- Fancy file input / dropzone -->
        <div class="dropzone" id="dropzone">
          <div>
            <div class="dz-title">Choose or drop your QR images</div>
            <div class="dz-sub">ZIP or multiple images. Trimming removes outer white borders.</div>
            <div class="dz-actions">
              <button class="btn" id="chooseBtn" type="button">Choose files</button>
              <button class="btn ghost" id="arrange" type="button">Arrange → PDF</button>
              <a id="downloadPdf" class="btn ghost" download="qr_a4_layout.pdf" href="#" aria-disabled="true">Download PDF</a>
            </div>
          </div>
          <input id="files" type="file" accept=".zip,image/*" multiple />
        </div>
        <div class="muted" id="fileNote"></div>

        <!-- Sizing + options -->
        <div class="row">
          <div class="field"><span>QR tile (mm)</span><input id="qrSize" type="number" value="15" step="0.1" min="3"></div>
          <div class="field"><span>Gap (mm)</span><input id="gap" type="number" value="5" step="0.1" min="0"></div>
          <label class="field" style="gap:.5rem"><input id="autoFit" type="checkbox" checked> <span>Auto‑fit to one page</span></label>
        </div>

        <div class="row">
          <label class="field" style="gap:.5rem"><input id="trim" type="checkbox" checked> <span>Trim outer white/transparent border</span></label>
          <div class="field"><span>Inner padding (mm)</span><input id="pad" type="number" value="0" step="0.1" min="0"></div>
          <label class="field" style="gap:.5rem"><input id="rulers" type="checkbox"> <span>Add 100 mm rulers</span></label>
        </div>

        <div>
          <progress id="prog" value="0" max="100" hidden></progress>
          <div id="note" class="muted" style="margin-top:.35rem"></div>
        </div>
      </div>
    </section>

    <section class="grid">
      <div class="card">
        <h3 style="margin:.2rem 0 .8rem">Preview (scaled)</h3>
        <canvas id="preview" width="840" height="1188" aria-label="Preview canvas"></canvas>
        <p class="muted" style="margin:.5rem 0 0">
          Tip: For a true 0.5 cm gap, set Gap = 5 mm, keep Trim ON, Padding = 0, and print the PDF at 100% (no fit/scaling).
        </p>
      </div>
      <div class="card">
        <h3 style="margin:.2rem 0 .8rem">Quick notes</h3>
        <ul class="muted" style="margin:.2rem 0 0; padding-left:1rem; list-style:disc">
          <li>Use ZIP for many images</li>
          <li>2 cm margins ensure printers don’t clip</li>
          <li>Auto‑fit shrinks tiles so everything fits on one page</li>
          <li>A4 is 210 × 297 mm; layout and PDF use precise millimeters</li>
        </ul>
      </div>
    </section>

    <div class="info">© <span id="year"></span> Made by ANABRATA</div>
  </main>

  <!-- Libraries -->
  <script src="https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/jspdf@2.5.1/dist/jspdf.umd.min.js"></script>

  <script>
  // Year
  document.getElementById('year').textContent = new Date().getFullYear();

  // Constants
  const PAGE_W_MM = 210, PAGE_H_MM = 297; // A4
  const MARGIN_MM = 20; // 2 cm
  const MAX_IMAGES = 200; // performance cap (not displayed)

  // Elements
  const $ = id => document.getElementById(id);
  const filesEl = $('files');
  const chooseBtn = $('chooseBtn');
  const dz = $('dropzone');
  const fileNote = $('fileNote');

  const arrangeBtn = $('arrange');
  const downloadPdf = $('downloadPdf');
  const note = $('note');
  const prog = $('prog');
  const canvas = $('preview');
  const ctx = canvas.getContext('2d');

  const qrSizeInput = $('qrSize');
  const gapInput = $('gap');
  const autoFitInput = $('autoFit');
  const trimInput = $('trim');
  const padInput = $('pad');
  const rulersInput = $('rulers');

  // --- Dropzone interactions (input is hidden; it won't block buttons) ---
  chooseBtn.addEventListener('click', () => filesEl.click());
  dz.addEventListener('dragover', (e) => { e.preventDefault(); dz.classList.add('drag'); });
  dz.addEventListener('dragleave', () => dz.classList.remove('drag'));
  dz.addEventListener('drop', (e) => {
    e.preventDefault(); dz.classList.remove('drag');
    filesEl.files = e.dataTransfer.files;
    updateFileNote();
  });
  filesEl.addEventListener('change', updateFileNote);
  function updateFileNote(){
    const n = filesEl.files?.length || 0;
    fileNote.textContent = n ? `${n} file(s) selected` : '';
  }

  // --- File reading helpers ---
  function blobToImage(blob){
    return new Promise((res, rej) => {
      const url = URL.createObjectURL(blob);
      const img = new Image();
      img.onload = () => { URL.revokeObjectURL(url); res(img); };
      img.onerror = rej;
      img.src = url;
    });
  }
  async function readAllImagesFromInput(fileList){
    const imgs = [];
    const files = Array.from(fileList || []);
    const zips = files.filter(f => f.name.toLowerCase().endsWith('.zip'));
    const singles = files.filter(f => !f.name.toLowerCase().endsWith('.zip'));

    for (const zf of zips){
      const zip = await JSZip.loadAsync(zf);
      const entries = Object.values(zip.files).filter(f => !f.dir && /\.(png|jpe?g|webp|bmp|gif|svg)$/i.test(f.name));
      for (const entry of entries){
        const blob = await entry.async("blob");
        const img = await blobToImage(blob);
        imgs.push(img);
        if (imgs.length >= MAX_IMAGES) break;
      }
      if (imgs.length >= MAX_IMAGES) break;
    }
    for (const f of singles){
      const img = await blobToImage(f);
      imgs.push(img);
      if (imgs.length >= MAX_IMAGES) break;
    }
    return imgs.slice(0, MAX_IMAGES);
  }

  // --- Trimming (to ensure visible gap is exact) ---
  function trimToContentCanvas(img, threshold = 250){
    const w = img.naturalWidth || img.width;
    const h = img.naturalHeight || img.height;
    const t = document.createElement('canvas');
    t.width = w; t.height = h;
    const c = t.getContext('2d');
    c.drawImage(img, 0, 0, w, h);
    const { data } = c.getImageData(0, 0, w, h);

    let minX = w, minY = h, maxX = -1, maxY = -1;
    for (let y=0; y<h; y++){
      for (let x=0; x<w; x++){
        const i = (y*w + x) * 4;
        const r = data[i], g = data[i+1], b = data[i+2], a = data[i+3];
        const opaque = a > 10;
        const notWhite = (r < threshold || g < threshold || b < threshold);
        if ((opaque && notWhite) || (!opaque && (r+g+b) < 3)){
          if (x < minX) minX = x;
          if (y < minY) minY = y;
          if (x > maxX) maxX = x;
          if (y > maxY) maxY = y;
        }
      }
    }
    if (maxX < minX || maxY < minY) return t;
    const tw = Math.max(1, maxX - minX + 1);
    const th = Math.max(1, maxY - minY + 1);
    const out = document.createElement('canvas');
    out.width = tw; out.height = th;
    out.getContext('2d').drawImage(t, minX, minY, tw, th, 0, 0, tw, th);
    return out;
  }
  function imageToCanvas(img){
    const w = img.naturalWidth || img.width;
    const h = img.naturalHeight || img.height;
    const t = document.createElement('canvas');
    t.width = w; t.height = h;
    t.getContext('2d').drawImage(img, 0, 0, w, h);
    return t;
  }
  function prepareImages(imgs, doTrim){
    return imgs.map(img => doTrim ? trimToContentCanvas(img) : imageToCanvas(img));
  }
  function canvasToJpegDataURL(cv, q=0.9){ return cv.toDataURL('image/jpeg', q); }

  // --- Preview layout (scaled to A4 width) ---
  function previewLayout(prepared, tileMM, gapMM, padMM, showRulers){
    const pageWmm = PAGE_W_MM, pageHmm = PAGE_H_MM;
    const pxPerMM = canvas.width / pageWmm;
    const pageWpx = Math.round(pageWmm * pxPerMM);
    const pageHpx = Math.round(pageHmm * pxPerMM);
    const marginPx = Math.round(MARGIN_MM * pxPerMM);
    const availW = pageWpx - 2*marginPx;
    const availH = pageHpx - 2*marginPx;

    let tilePx = Math.max(1, Math.round(tileMM * pxPerMM));
    let gapPx  = Math.max(0, Math.round(gapMM  * pxPerMM));
    let padPx  = Math.max(0, Math.round(padMM  * pxPerMM));

    function fit(tile, gap){
      const cols = Math.max(1, Math.floor((availW + gap) / (tile + gap)));
      const rows = Math.max(1, Math.floor((availH + gap) / (tile + gap)));
      return { cols, rows, capacity: cols * rows };
    }
    let { cols, rows, capacity } = fit(tilePx, gapPx);
    if (capacity < prepared.length && autoFitInput.checked){
      while (capacity < prepared.length && tilePx > 3){
        tilePx -= 1;
        ({ cols, rows, capacity } = fit(tilePx, gapPx));
      }
    }

    // Paint page + margin guide
    ctx.fillStyle = '#ffffff'; ctx.fillRect(0,0,pageWpx,pageHpx);
    ctx.strokeStyle = '#d1d5db'; ctx.lineWidth = 1;
    ctx.strokeRect(marginPx + .5, marginPx + .5, availW - 1, availH - 1);

    // Optional rulers (100 mm)
    if (showRulers){
      ctx.strokeStyle = '#9ca3af'; ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.moveTo(marginPx, marginPx + Math.round(10 * pxPerMM));
      ctx.lineTo(marginPx + Math.round(100 * pxPerMM), marginPx + Math.round(10 * pxPerMM));
      ctx.moveTo(marginPx + Math.round(10 * pxPerMM), marginPx);
      ctx.lineTo(marginPx + Math.round(10 * pxPerMM), marginPx + Math.round(100 * pxPerMM));
      ctx.stroke();
    }

    // Draw tiles
    let i = 0;
    for (let r=0; r<rows && i<prepared.length; r++){
      for (let c=0; c<cols && i<prepared.length; c++){
        const x = marginPx + c * (tilePx + gapPx);
        const y = marginPx + r * (tilePx + gapPx);
        const inner = prepared[i];
        const w = Math.max(1, tilePx - 2*padPx);
        ctx.drawImage(inner, x + padPx, y + padPx, w, w);
        i++;
      }
    }
    return { placed: Math.min(prepared.length, capacity), cols, rows };
  }

  // --- PDF builder (A4 mm accurate) ---
  async function buildPdf(prepared, tileMM, gapMM, padMM, showRulers){
    const { jsPDF } = window.jspdf;
    const doc = new jsPDF({ unit: 'mm', format: [PAGE_W_MM, PAGE_H_MM] });

    const availW = PAGE_W_MM - 2*MARGIN_MM;
    const availH = PAGE_H_MM - 2*MARGIN_MM;

    function fit(tile, gap){
      const cols = Math.max(1, Math.floor((availW + gap) / (tile + gap)));
      const rows = Math.max(1, Math.floor((availH + gap) / (tile + gap)));
      return { cols, rows, capacity: cols * rows };
    }

    let tile = tileMM, gap = gapMM, pad = padMM;
    let { cols, rows, capacity } = fit(tile, gap);
    if (capacity < prepared.length && autoFitInput.checked){
      for (let k=0; k<800 && capacity < prepared.length; k++){
        tile = Math.max(3, Math.round((tile - 0.2) * 10) / 10);
        ({ cols, rows, capacity } = fit(tile, gap));
        if (tile <= 3) break;
      }
    }

    // Optional rulers
    if (showRulers){
      doc.setDrawColor(180);
      doc.line(MARGIN_MM, MARGIN_MM + 10, MARGIN_MM + 100, MARGIN_MM + 10);
      doc.line(MARGIN_MM + 10, MARGIN_MM, MARGIN_MM + 10, MARGIN_MM + 100);
      doc.setDrawColor(0);
    }

    let i = 0;
    for (let r=0; r<rows && i<prepared.length; r++){
      for (let c=0; c<cols && i<prepared.length; c++){
        const x = MARGIN_MM + c * (tile + gap);
        const y = MARGIN_MM + r * (tile + gap);
        const inner = prepared[i];
        const w = Math.max(0.1, tile - 2*pad);
        const dataUrl = canvasToJpegDataURL(inner, 0.9);
        doc.addImage(dataUrl, 'JPEG', x + pad, y + pad, w, w);
        i++;
      }
    }
    return doc.output('blob');
  }

  // --- Arrange → PDF ---
  arrangeBtn.onclick = async () => {
    try{
      note.textContent = "Reading files…";
      prog.hidden = false; prog.value = 5;

      const imgs = await readAllImagesFromInput(filesEl.files);
      if (!imgs.length){ note.textContent = "No images found. Choose or drop your QR images first."; prog.hidden = true; return; }
      if (imgs.length > MAX_IMAGES) imgs.length = MAX_IMAGES;
      fileNote.textContent = `${imgs.length} image(s) loaded`;

      prog.value = 25; note.textContent = "Preparing images…";
      const prepared = prepareImages(imgs, !!trimInput.checked);

      const tileMM = parseFloat(qrSizeInput.value) || 15;
      const gapMM  = parseFloat(gapInput.value) || 5;
      const padMM  = Math.max(0, parseFloat(padInput.value) || 0);
      const showRulers = !!rulersInput.checked;

      prog.value = 45; note.textContent = "Arranging on page…";
      previewLayout(prepared, tileMM, gapMM, padMM, showRulers);

      prog.value = 70; note.textContent = "Building PDF… (this can take a moment)";
      const blob = await buildPdf(prepared, tileMM, gapMM, padMM, showRulers);

      const url = URL.createObjectURL(blob);
      downloadPdf.href = url;
      downloadPdf.setAttribute('aria-disabled','false');

      prog.value = 100; note.textContent = "PDF ready. Download and print at 100% scale.";
      setTimeout(() => prog.hidden = true, 400);
    } catch(e){
      console.error(e);
      note.textContent = "Error: " + e.message;
      prog.hidden = true;
    }
  };
  </script>
</body>
</html>
