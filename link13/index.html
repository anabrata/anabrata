<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
<title>Minimal Fast 3D Human Cell</title>
<script src="https://cdn.plot.ly/plotly-2.34.0.min.js"></script>
<style>
  html, body {
    margin: 0; padding: 0; height: 100%; overflow: hidden;
    font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
    background: #1b1e3c;
    color: #eee;
    user-select: none;
    -webkit-user-select: none;
  }
  #plot {
    width: 100vw; height: 100vh;
  }
  #status {
    position: absolute; left: 12px; bottom: 12px;
    background: rgba(0,0,0,0.8);
    padding: 8px 14px;
    border-radius: 12px;
    font-size: 14px;
    color: #fff;
    z-index: 100;
    user-select: none;
  }
  .panel {
    position: absolute;
    right: 10px; top: 50px;
    width: min(350px, 90vw);
    max-height: 70vh;
    overflow-y: auto;
    background: rgba(40,40,60,0.9);
    border: 1px solid rgba(255,255,255,0.15);
    border-radius: 14px;
    padding: 16px 20px;
    z-index: 101;
    color: #ccddee;
    font-size: 14px;
    line-height: 1.4;
    opacity: 0;
    pointer-events: none;
    transition: all 0.4s ease;
  }
  .panel.show {
    opacity: 1;
    pointer-events: auto;
  }
  .panel h3 {
    margin: 0 0 12px 0;
    font-weight: 700;
    font-size: 22px;
  }
  .panel p {
    margin: 0 0 14px 0;
  }
  .panel .close {
    position: absolute;
    top: 10px; right: 12px;
    background: none; border: none;
    color: #bbb;
    font-size: 24px;
    cursor: pointer;
    opacity: 0.8;
    transition: opacity 0.2s ease;
  }
  .panel .close:hover {
    opacity: 1;
  }
</style>
</head>
<body>
  <div id="status">Loading 3D cell model...</div>
  <div id="plot" role="img" aria-label="Minimal 3D human cell model"></div>

  <div id="panel" class="panel" role="region" aria-live="polite" aria-labelledby="orgTitle" tabindex="0">
    <button class="close" id="closePanel" title="Close info panel" aria-label="Close panel">√ó</button>
    <h3 id="orgTitle">Click an organelle</h3>
    <p id="orgIntro">Tap or click an organelle in the 3D model to see details here.</p>
  </div>

  <script>
  (function() {
    const statusEl = document.getElementById('status');
    const plotEl = document.getElementById('plot');
    const panel = document.getElementById('panel');
    const titleEl = document.getElementById('orgTitle');
    const introEl = document.getElementById('orgIntro');
    const closeBtn = document.getElementById('closePanel');

    closeBtn.addEventListener('click', () => { panel.classList.remove('show'); });

    // Basics
    function linspace(a,b,n) {
      if (n<2) return [a];
      let s=(b - a)/(n -1);
      let arr= new Array(n);
      for(let i=0; i<n; i++) arr[i] = a + s*i;
      return arr;
    }
    function zerosLike2D(M){
      return M.map(row => row.map(_=>0));
    }
    function ellipsoid(center, radii, nu=10, nv=8) {
      const [cx,cy,cz] = center;
      const [rx,ry,rz] = radii;
      const u = linspace(0, 2*Math.PI, nu);
      const v = linspace(0, Math.PI, nv);
      const X = [], Y = [], Z = [];
      for(let i=0; i<nu; i++) {
        const Xrow = [], Yrow = [], Zrow = [];
        const cu = Math.cos(u[i]), su = Math.sin(u[i]);
        for(let j=0; j<nv; j++) {
          const sv = Math.sin(v[j]), cv = Math.cos(v[j]);
          Xrow.push(rx*cu*sv + cx);
          Yrow.push(ry*su*sv + cy);
          Zrow.push(rz*cv + cz);
        }
        X.push(Xrow); Y.push(Yrow); Z.push(Zrow);
      }
      return {X, Y, Z};
    }
    function surface(X,Y,Z,color,opacity,name) {
      return {
        type: 'surface', x: X, y: Y, z: Z,
        surfacecolor: zerosLike2D(X),
        colorscale: [[0,color],[1,color]],
        showscale: false, opacity: opacity, name: name, hoverinfo: 'name',
        lighting: {ambient: 1, diffuse: 0.5, specular: 0.2, roughness: 0.8},
        contours: {x:{show:false}, y:{show:false}, z:{show:false}}
      };
    }
    function lineTrace(xs, ys, zs, color, width, name) {
      return {type: 'scatter3d', mode: 'lines',
              x: xs, y: ys, z: zs,
              line: {color: color, width: width},
              name: name, hoverinfo: 'name', opacity: 0.5};
    }
    function polyline3d(fn, t0, t1, steps=60) {
      const t = linspace(t0, t1, steps);
      const X = [], Y = [], Z = [];
      for(let i=0; i<steps; i++) {
        const p = fn(t[i]);
        X.push(p[0]); Y.push(p[1]); Z.push(p[2]);
      }
      return {X, Y, Z};
    }

    function randomPoints(n, inner, outer, avoidC=null, avoidR=0, seed=123) {
      Math.seedrandom(seed);
      const points=[];
      let count=0;
      while(points.length < n && count < 20000) {
        let u= Math.random();
        let r= Math.pow((Math.pow(outer,3)-Math.pow(inner,3))*u + Math.pow(inner,3), 1/3);
        let z= 2*Math.random()-1;
        let angle= 2*Math.PI*Math.random();
        let s= Math.sqrt(1 - z*z);
        let x= r*s*Math.cos(angle);
        let y= r*s*Math.sin(angle);
        let dist = avoidC ? Math.sqrt( (x - avoidC[0])**2 + (y - avoidC[1])**2 + (z - avoidC[2])**2 ) : 9999;
        if(dist > avoidR) points.push([x,y,z]);
        count++;
      }
      // restore normal random
      Math.random = () => crypto.getRandomValues(new Uint32Array(1))[0] / 4294967296;
      return points;
    }

    // Info text
    const INFO = {
      'Cell membrane': 'Phospholipid bilayer surrounding the cell.',
      'Nucleus': 'Cell control center containing DNA.',
      'Mitochondrion': 'Produces energy for the cell.',
      'Golgi apparatus': 'Packages and ships proteins.',
      'Rough ER': 'Protein synthesis site with ribosomes.',
      'Smooth ER': 'Lipid synthesis and detoxification.',
      'Ribosome': 'Protein assembly machines.',
      'DNA Helix': 'Genetic information molecule.'
    };

    function openInfo(name) {
      titleEl.textContent = name;
      introEl.textContent = INFO[name] || 'No detailed info available.';
      panel.classList.add('show');
    }

    // Build core cell parts with minimal polygons and counts
    const CELL_R = 10;
    const NUCLEUS_R = 3.5;

    const traces = [];
    traces.push(surface(...Object.values(ellipsoid([0,0,0],[CELL_R,CELL_R*0.95,CELL_R*0.90])), '#779977', 0.3, 'Cell membrane'));

    traces.push(surface(...Object.values(ellipsoid([1,0,0],[NUCLEUS_R*1.1,NUCLEUS_R,NUCLEUS_R*0.9])), '#aa88cc', 0.5, 'Nucleus'));

    // Mitochondria 5 units
    const mitoCenters = randomPoints(5, NUCLEUS_R+2, CELL_R-2, [1,0,0], NUCLEUS_R+1, 456);
    mitoCenters.forEach(c => traces.push(surface(...Object.values(ellipsoid(c,[1.1,0.6,0.6])), '#d2691e', 0.8, 'Mitochondrion')));

    // Golgi apparatus 3 stacks
    for(let i=0; i<3; i++){
      let pos = [3 + 0.15*i, -1 + 0.05*i, 0.5];
      traces.push(surface(...Object.values(ellipsoid(pos,[1.3,0.7,0.22])), '#deb887', 0.9, 'Golgi apparatus'));
    }

    // Rough ER 2 branches
    const roughERParams = [[-0.7,0.3,0,0.8,2.9,2,0],[0.2,0.6,0,0.7,2.5,2,1]];
    roughERParams.forEach(params => {
      const [cx,cy,cz,amp,rad,twist,phase] = params;
      let pl = polyline3d(t => [
        cx+(rad+amp*Math.sin(t*twist+phase))*Math.cos(t),
        cy+(rad+amp*Math.cos(t*twist+phase))*Math.sin(t),
        cz+0.4*Math.sin(1.4*t+phase)
      ], 0, 2*Math.PI, 140);
      traces.push(lineTrace(pl.X, pl.Y, pl.Z, '#6d8a42', 5, 'Rough ER'));
    });

    // Smooth ER 1 branch
    const smoothERCurve = polyline3d(t => [
      1.0+(2.8)*Math.cos(t*1.7+0.8),
      0.1 + 0.25*Math.sin(t*1.7+0.8),
      0.4*Math.sin(1.4*t+0.8)
    ], 0, 2*Math.PI, 120);
    traces.push(lineTrace(smoothERCurve.X, smoothERCurve.Y, smoothERCurve.Z, '#497230', 4, 'Smooth ER'));

    // Ribosomes 20 units small spheres
    const ribCenters = randomPoints(20, NUCLEUS_R+1.3, CELL_R-1.8, [1,0,0], NUCLEUS_R+0.7, 789);
    ribCenters.forEach(c => traces.push(surface(...Object.values(ellipsoid(c,[0.35,0.35,0.3])), '#4a6f4a', 0.8, 'Ribosome')));

    // DNA Helix (line)
    const dnaHelix = polyline3d(t => {
      let r = 0.3;
      return [
        r*Math.cos(5*t + Math.PI/2),
        r*Math.sin(5*t + Math.PI/2),
        0.05*t - 3
      ];
    }, 0, 10*Math.PI, 100);
    traces.push(lineTrace(dnaHelix.X, dnaHelix.Y, dnaHelix.Z, 'rgb(190,110,50)', 2.5, 'DNA Helix'));

    const layout = {
      scene: {
        xaxis: {visible:false}, yaxis:{visible:false}, zaxis:{visible:false},
        aspectmode: 'data', camera: {eye: {x:1.7,y:2,z:1.2}},
        bgcolor: 'rgba(0,0,0,0)'
      },
      margin: {l:0,r:0,t:0,b:0},
      paper_bgcolor: 'rgba(0,0,0,0)',
      showlegend: true,
      legend: {orientation:'h', yanchor:'bottom', y:0.02, xanchor:'center', x:0.5, font:{color:'#eee', size:12}}
    };

    const config = {
      responsive: true,
      displayModeBar: false,
      scrollZoom: true,
      scrollZoomSpeed: 0.15,
      doubleClick: 'reset',
      staticPlot: true
    };

    Plotly.newPlot(plotEl, traces, layout, config).then(() => {
      statusEl.textContent = 'Fast 3D Cell loaded ‚Ä¢ Tap organelles for info';
      statusEl.style.opacity = '0';
      config.staticPlot = false; // enable interaction after initial load
    }).catch(e => {
      statusEl.classList.add('error');
      statusEl.textContent = 'Render error: ' + e.message;
    });

    plotEl.on('plotly_click', function(ev) {
      if(!ev || !ev.points || !ev.points.length) return;
      openInfo(ev.points[0].fullData.name || 'Cell structure');
    });

    window.addEventListener('resize', () => Plotly.Plots.resize(plotEl));
  })();
  </script>
</body>
</html>
      const statusEl = document.getElementById('status');
      const plotEl = document.getElementById('plot');
      
      function linspace(a,b,n){
        if(n<2) return [a];
        const s=(b-a)/(n-1), arr=new Array(n);
        for(let i=0; i<n; i++) arr[i]=a+s*i;
        return arr;
      }
      function zerosLike2D(M){
        const Z=new Array(M.length);
        for(let i=0; i<M.length; i++){
          Z[i] = new Array(M[i].length).fill(0);
        }
        return Z;
      }
      function ellipsoid(center, radii, nu=16, nv=12){
        const [cx,cy,cz]=center, [rx,ry,rz]=radii;
        const u=linspace(0,2*Math.PI,nu), v=linspace(0,Math.PI,nv);
        const X=new Array(nu), Y=new Array(nu), Z=new Array(nu);
        for(let i=0; i<nu; i++){
          const cu=Math.cos(u[i]), su=Math.sin(u[i]);
          X[i] = new Array(nv); Y[i] = new Array(nv); Z[i] = new Array(nv);
          for(let j=0; j<nv; j++){
            const sv=Math.sin(v[j]), cv=Math.cos(v[j]);
            X[i][j] = rx*cu*sv+cx;
            Y[i][j] = ry*su*sv+cy;
            Z[i][j] = rz*cv+cz;
          }
        }
        return {X,Y,Z};
      }
      function surface(X,Y,Z,color,opacity,name){
        return {
          type:'surface', x:X, y:Y, z:Z,
          surfacecolor: zerosLike2D(X),
          colorscale: [[0,color],[1,color]],
          showscale:false, opacity:opacity, name:name, hoverinfo:'name',
          lighting:{ambient:0.7,diffuse:0.7,specular:0.2,roughness:0.8},
          contours:{x:{show:false}, y:{show:false}, z:{show:false}}
        };
      }
      function lineTrace(xs,ys,zs,color,width,name){
        return {type:'scatter3d',mode:'lines', x:xs, y:ys, z:zs, line:{color,width}, name, hoverinfo:'name', opacity:0.6};
      }
      function polyline3d(curveFn, t0, t1, steps=80){
        const t=linspace(t0,t1,steps);
        const X=[], Y=[], Z=[];
        for(let i=0; i<steps; i++){
          const p=curveFn(t[i]);
          X.push(p[0]); Y.push(p[1]); Z.push(p[2]);
        }
        return {X,Y,Z};
      }

      // Information for tooltips
      const INFO = {
        'Cell membrane': 'Phospholipid bilayer enclosing the cell.',
        'Plasma membrane': 'Alternate term for cell membrane.',
        'Cytoplasm': 'Gel-like substance within cell.',
        'Nucleus': 'Contains DNA and regulates cellular activity.',
        'Mitochondrion': 'Produces energy (ATP) for the cell.',
        'Golgi apparatus': 'Packages and ships proteins and lipids.',
        'Rough ER': 'Studded with ribosomes; synthesizes proteins.',
        'Smooth ER': 'Lipid synthesis and detoxification.',
        'Ribosome': 'Protein synthesis machinery.',
        'DNA Helix': 'DNA molecule inside nucleus.',
      };

      // Build the cell model
      const CELL_R = 10;
      const NUCLEUS_R = 3.5;
      const traces = [];

      // Cytoplasm (transparent)
      traces.push(surface(...Object.values(ellipsoid([0,0,0],[CELL_R*0.95,CELL_R*0.95,CELL_R*0.90])), '#445566', 0.04, 'Cytoplasm'));

      // Plasma Membrane
      traces.push(surface(...Object.values(ellipsoid([0,0,0],[CELL_R,CELL_R,CELL_R*0.95])), '#779977', 0.25, 'Plasma membrane'));

      // Nucleus
      traces.push(surface(...Object.values(ellipsoid([1,0,0],[NUCLEUS_R*1.1,NUCLEUS_R,NUCLEUS_R*0.9])), '#aa88cc', 0.5, 'Nucleus'));

      // Mitochondria (6 units)
      const mitoCenters = [
        [5,2,1], [4,-3,-1], [-3,3,2], [-4,-4,-1], [2,-5,2], [3,3,-3]
      ];
      mitoCenters.forEach(c => {
        traces.push(surface(...Object.values(ellipsoid(c,[1.1,0.6,0.6])), '#d2691e', 0.8, 'Mitochondrion'));
      });

      // Golgi apparatus (4 stacks)
      for(let i=0;i<4;i++) {
        const center = [3 + 0.15*i, -2 + 0.1*i, 0.5];
        traces.push(surface(...Object.values(ellipsoid(center,[1.4,0.7,0.25])), '#deb887', 0.85, 'Golgi apparatus'));
      }

      // Rough ER (2 branches)
      function erCurve(cx,cy,cz,amp,rad,twist,phase){
        return t => [
          cx+(rad+amp*Math.sin(t*twist+phase))*Math.cos(t),
          cy+(rad+amp*Math.cos(t*twist+phase))*Math.sin(t),
          cz+0.4*Math.sin(1.4*t + phase)
        ];
      }
      [[-0.7,0.3,0,0.9,3,2,0],[0.1,0.6,0,0.8,2.6,2,1]].forEach(params => {
        const pl = polyline3d(erCurve(...params), 0, 2*Math.PI, 140);
        traces.push(lineTrace(pl.X,pl.Y,pl.Z,'#689f38',6,'Rough ER'));
      });
      // Smooth ER (1 branch)
      const smoothCurve = polyline3d(erCurve(1.0, 0.1, 0, 0.7, 2.9, 1.8, 0.7), 0, 2*Math.PI, 110);
      traces.push(lineTrace(smoothCurve.X, smoothCurve.Y, smoothCurve.Z, '#3f7d20', 4, 'Smooth ER'));

      // Ribosomes (25 points)
      const ribCenters = [
        [1,1,0], [1.5, 0.3, 0.5], [0.3, 1.7, 0], [0.8, -0.8, 0.5], [-1, 0.4, 0.5],
        [2, -1.5, 0.2], [2.1, 1, 0.2], [-0.8, -1, 0.7], [0,-1.5, 1.0], [1.8, 1.8, 0],
        [4,1,0], [3, 2, 1], [1,-2,0.5], [0,2,0.6]
      ];
      ribCenters.forEach(c => {
        traces.push(surface(...Object.values(ellipsoid(c,[0.3,0.3,0.25])), '#4a6f4a', 0.8, 'Ribosome'));
      });

      // DNA helix inside nucleus
      function dnaHelix(t){
        const radius=0.28;
        const height = 0.05*t - 3;
        return [
          radius * Math.cos(5*t + Math.PI/2),
          radius * Math.sin(5*t + Math.PI/2),
          height
        ];
      }
      const dnaPl = polyline3d(dnaHelix,0,10*Math.PI, 110);
      traces.push(lineTrace(dnaPl.X, dnaPl.Y, dnaPl.Z, 'rgb(200,120,70)', 2.5, 'DNA Helix'));

      const layout = {
        scene: {
          xaxis: {visible:false},
          yaxis: {visible:false},
          zaxis: {visible:false},
          aspectmode: 'data',
          camera: {eye: {x:1.8,y:2,z:1.2}},
          bgcolor: 'rgba(0,0,0,0)'
        },
        margin: {l:0,r:0,t:0,b:0},
        paper_bgcolor: 'rgba(0,0,0,0)',
        showlegend: true,
        legend: {orientation:'h', yanchor:'bottom', y:0.02, xanchor:'center', x:0.5, font: {color:'#eee', size:11}}
      };

      const config = {
        responsive:true,
        displayModeBar:false,
        scrollZoom:true,
        scrollZoomSpeed:0.2,
        doubleClick:'reset',
        staticPlot:false
      };

      function openInfo(name){
        const INFO = {
          'Cell membrane': 'The membrane controls exchange and protects the cell.',
          'Plasma membrane': 'Selective permeability barrier.',
          'Cytoplasm': 'Fluid that fills the cell.',
          'Nucleus': 'Control center with DNA.',
          'Nucleolus': 'Ribosome factory in nucleus.',
          'Mitochondrion': 'Powerhouse generates ATP.',
          'Golgi apparatus': 'Modifies & ships proteins.',
          'Rough ER': 'Protein synthesis with ribosomes.',
          'Smooth ER': 'Lipid synthesis & detoxification.',
          'Ribosome': 'Protein production machinery.',
          'DNA Helix': 'Genetic code carrier in nucleus.'
        };
        const infoText = INFO[name] || 'Information not available.';
        document.getElementById('orgTitle').textContent = name;
        document.getElementById('orgIntro').textContent = infoText;
        panel.classList.add('show');
      }

      Plotly.newPlot(plotEl, traces, layout, config).then(()=>{
        statusEl.textContent = 'Loaded ‚Ä¢ Tap organelles for info';
        setTimeout(()=>{ statusEl.style.opacity = 0; }, 3500);
      }).catch(e=>{
        statusEl.classList.add('error');
        statusEl.textContent = 'Render error: ' + e.message;
      });

      plotEl.on('plotly_click', function(ev){
        if(!ev || !ev.points || !ev.points.length) return;
        const name = ev.points[0].fullData.name || 'Structure';
        openInfo(name);
      });

      window.addEventListener('resize', () => Plotly.Plots.resize(plotEl));
      document.getElementById('closePanel').addEventListener('click', () => panel.classList.remove('show'));
    })();
  </script>

  <div id="panel" class="panel" role="region" aria-live="polite" aria-labelledby="orgTitle" tabindex="0">
    <button class="close" id="closePanel" title="Close Panel" aria-label="Close info panel">√ó</button>
    <h3 id="orgTitle">Click an organelle</h3>
    <p id="orgIntro">Tap an organelle in the 3D model to see details here.</p>
  </div>

</body>
</html>
and secreted proteins.',
      'Smooth ER': 'Lacks ribosomes; synthesizes lipids and detoxifies chemicals.',
      'Ribosome': 'Translates mRNA into proteins; free or bound to rough ER.',
      'Lysosome': 'Contains digestive enzymes to break down waste and worn cell parts.',
      'Peroxisome': 'Detoxifies harmful substances and breaks down fatty acids.',
      'Centrosome': 'Contains centrioles; organizes microtubules and cell division.',
      'Cytoskeleton': 'Protein filaments providing shape, mechanical resistance, and trafficking.',
      'Chromatin (DNA)': 'Complex of DNA and proteins in the nucleus storing genetic info.',
      'DNA': 'Double-helix molecule carrying genetic instructions for development and functioning.',
      'RNA': 'Single-stranded molecule responsible for protein synthesis and gene expression regulation.',
      'Vesicle': 'Small membrane-bound sac transporting materials within the cell.'
    };

    function create3DOrganelle(name, el) {
      const traces = [];
      switch(name) {
        case 'Mitochondrion':
          const outer = ellipsoid([0,0,0], [1.2,0.6,0.6], 30, 20);
          traces.push(surface(outer.X,outer.Y,outer.Z, '#d08770',0.7,'Outer membrane'));
          const inner = ellipsoid([0,0,0], [1.0,0.5,0.5], 26, 16);
          traces.push(surface(inner.X,inner.Y,inner.Z, '#bf616a',0.8,'Inner membrane'));
          break;
        case 'Nucleus':
          const nuc = ellipsoid([0,0,0], [1.5,1.4,1.3], 36, 24);
          traces.push(surface(nuc.X, nuc.Y, nuc.Z, '#b48ead', 0.45, 'Nuclear envelope'));
          const nucleolus = ellipsoid([0.3,0.2,0.1], [0.4,0.4,0.35], 24, 16);
          traces.push(surface(nucleolus.X, nucleolus.Y, nucleolus.Z, '#bf616a', 0.8, 'Nucleolus'));
          break;
        case 'Golgi apparatus':
          for(let i=0; i<5; i++){
            const cisterna = ellipsoid([0.15*i,0.05*i,0], [1.1*(1-i*0.15), 0.6*(1-i*0.15), 0.12], 26, 14);
            traces.push(surface(cisterna.X, cisterna.Y, cisterna.Z, '#ebcb8b', 0.9, 'Cisterna ' + (i+1)));
          }
          break;
        case 'Ribosome':
          const large = ellipsoid([0,0,0.1], [0.3,0.3,0.25], 20, 14);
          const small = ellipsoid([0,0,-0.15], [0.25,0.25,0.2], 18, 12);
          traces.push(surface(large.X, large.Y, large.Z, '#5e81ac', 0.9, 'Large subunit'));
          traces.push(surface(small.X, small.Y, small.Z, '#81a1c1', 0.9, 'Small subunit'));
          break;
        case 'DNA':
          function dnaHelix(t){
            const radius=0.3;
            const height = 0.05*t - 3;
            return [
              radius * Math.cos(5*t + Math.PI/2),
              radius * Math.sin(5*t + Math.PI/2),
              height
            ];
          }
          const dnaPl = polyline3d(dnaHelix,0,12*Math.PI,140);
          traces.push(lineTrace(dnaPl.X, dnaPl.Y, dnaPl.Z, 'rgb(220,130,70)', 3, 'DNA Helix'));
          break;
        case 'RNA':
          function rnaSpiral(t){
            const radius = 0.25 + 0.07*Math.sin(7*t);
            return [
              radius * Math.cos(6*t + Math.PI/3),
              radius * Math.sin(6*t + Math.PI/3),
              0.06*t - 5
            ];
          }
          const rnaPl = polyline3d(rnaSpiral,0,15*Math.PI,120);
          traces.push(lineTrace(rnaPl.X,rnaPl.Y,rnaPl.Z,'rgb(120,180,200)',2.4,'RNA Strand'));
          break;
        case 'Centrosome':
          const c0=[0,0,0];
          const a1=[0.8,0,0.25];
          const a2=[0,0.8,-0.25];
          traces.push({
            type:'scatter3d',mode:'lines',
            x:[c0[0]-a1[0], c0[0]+a1[0]],
            y:[c0[1]-a1[1], c0[1]+a1[1]],
            z:[c0[2]-a1[2], c0[2]+a1[2]],
            line:{color:'#d08770',width:7},
            name:'Centrosome',hoverinfo:'name'
          });
          traces.push({
            type:'scatter3d',mode:'lines',
            x:[c0[0]-a2[0], c0[0]+a2[0]],
            y:[c0[1]-a2[1], c0[1]+a2[1]],
            z:[c0[2]-a2[2], c0[2]+a2[2]],
            line:{color:'#d08770',width:7},
            name:'Centrosome',hoverinfo:'name'
          });
          break;
        default:
          const gen = ellipsoid([0,0,0],[0.85,0.85,0.85], 24, 16);
          traces.push(surface(gen.X, gen.Y, gen.Z, '#88c999', 0.7, name));
      }
      const layout = {
        scene: {
          xaxis: {visible:false},
          yaxis: {visible:false},
          zaxis: {visible:false},
          aspectmode: 'data',
          camera: {eye: {x:1.5,y:1.5,z:1.2}},
          bgcolor: 'rgba(0,0,0,0)'
        },
        margin: { l:0, r:0, t:0, b:0 },
        paper_bgcolor: 'rgba(0,0,0,0)',
        showlegend: false
      };
      Plotly.newPlot(el, traces, layout, {responsive:true, displayModeBar:false});
    }

    function openInfo(name){
      titleEl.textContent = name;
      introEl.textContent = INFO[name] || 'Information unavailable.';
      panel.classList.add('show');
      setTimeout(() => create3DOrganelle(name, organelleViewerEl), 100);
    }

    // Main cell scene with proper organelle counts

    const CELL_R=10.0, NUCLEUS_R=3.5, NUCLEOLUS_R=1.2;
    const traces = [];

    // Cytoplasm
    const cytoEll = ellipsoid([0,0,0],[CELL_R*0.98,CELL_R*0.93,CELL_R*0.88],28,18);
    traces.push(surface(cytoEll.X, cytoEll.Y, cytoEll.Z, '#4c566a', 0.03, 'Cytoplasm'));
    
    // Plasma membrane (cell membrane)
    const membEll = ellipsoid([0,0,0],[CELL_R,CELL_R*0.95,CELL_R*0.90],48,28);
    traces.push(surface(membEll.X, membEll.Y, membEll.Z, '#88c999', 0.25, 'Plasma membrane'));

    // Nucleus
    const nucEll = ellipsoid([1.0,0.5,0.0],[NUCLEUS_R*1.05,NUCLEUS_R,NUCLEUS_R*0.9],40,24);
    traces.push(surface(nucEll.X, nucEll.Y, nucEll.Z, '#b48ead', 0.5, 'Nucleus'));

    // Nucleolus
    const nucleoEll = ellipsoid([1.4,0.8,0.2],[NUCLEOLUS_R,NUCLEOLUS_R,NUCLEOLUS_R*0.9],32,20);
    traces.push(surface(nucleoEll.X, nucleoEll.Y, nucleoEll.Z, '#bf616a', 0.85, 'Nucleolus'));

    // Chromatin (DNA strands)
    [ [1,0.5,0,1.2,1.5,0], [1,0.5,0,1,1.3,1.5], [1,0.5,0,0.7,1.1,3] ].forEach(p=>{
      let [cx, cy, cz, rad, turns, phase] = p;
      const cStr = polyline3d(t => [
        cx + (rad + 0.25*Math.sin(3*t+phase))*Math.cos(t),
        cy + (rad + 0.25*Math.cos(2*t+phase))*Math.sin(t),
        cz + 0.6*Math.sin(1.2*t+phase)
      ], 0, turns*2*Math.PI, 160);
      traces.push(lineTrace(cStr.X,cStr.Y,cStr.Z,'#d08770',3,'Chromatin (DNA)'));
    });

    // Mitochondria
    randomPointsInShell(10, NUCLEUS_R+2, CELL_R-2, [1,0.5,0], NUCLEUS_R+1, 101)
      .forEach(c => {
        const e = ellipsoid(c,[0.95,0.52,0.52],24,16);
        traces.push(surface(e.X, e.Y, e.Z, '#d08770', 0.85, 'Mitochondrion'));
      });

    // Golgi apparatus
    const golgiStart = [3.1,-0.82,0.4];
    [1,0.9,0.8,0.7].forEach((scale,i) => {
      const c = [golgiStart[0]+0.14*i, golgiStart[1]+0.035*i, golgiStart[2]];
      const e = ellipsoid(c,[1.6*scale,0.75*scale,0.18*scale],28,14);
      traces.push(surface(e.X, e.Y, e.Z, '#ebcb8b',0.9,'Golgi apparatus'));
    });

    // Rough ER (2 branches)
    const roughERParams = [
      [-0.8,0.3,0,0.9,3.5,2,0],
      [-0.3,0.6,0,0.8,3.1,2,1]
    ];
    roughERParams.forEach(params => {
      const [cx,cy,cz,amp,rad,twist,phase] = params;
      const pl=polyline3d(t=>[
        cx+(rad+amp*Math.sin(t*twist+phase))*Math.cos(t),
        cy+(rad+amp*Math.cos(t*twist+phase))*Math.sin(t),
        cz+0.4*Math.sin(1.4*t+phase)
      ],0,2*Math.PI,180);
      traces.push(lineTrace(pl.X,pl.Y,pl.Z,'#a3be8c',6,'Rough ER'));
    });

    // Smooth ER (1 branch)
    const smoothERCurve = polyline3d(t => [
      0.8 + (3 - 0.3 * t / (2*Math.PI)) * Math.cos(t*1.8 + 0.8),
      0.1+ 0.25 * Math.sin(t*1.8 + 0.8),
      0.4*Math.sin(1.4*t + 0.8)
    ], 0, 2*Math.PI, 150);
    traces.push(lineTrace(smoothERCurve.X, smoothERCurve.Y, smoothERCurve.Z, '#8fbcbb', 5, 'Smooth ER'));

    // Lysosomes (5)
    randomPointsInShell(5, NUCLEUS_R+1.8, CELL_R-2, [1,0.5,0], NUCLEUS_R+1, 202).forEach(c => {
      const e = ellipsoid(c,[0.4,0.4,0.4],18,12);
      traces.push(surface(e.X, e.Y, e.Z, '#d08770', 0.75, 'Lysosome'));
    });

    // Peroxisomes (3)
    randomPointsInShell(3, NUCLEUS_R+1.6, CELL_R-2, [1,0.5,0], NUCLEUS_R+0.9, 303).forEach(c => {
      const e = ellipsoid(c,[0.35,0.35,0.35],18,12);
      traces.push(surface(e.X, e.Y, e.Z, '#a3be8c', 0.78, 'Peroxisome'));
    });

    // Vesicles (7)
    randomPointsInShell(7, NUCLEUS_R+1.4, CELL_R-1.8, [1,0.5,0], NUCLEUS_R+0.8, 404).forEach(c => {
      const e = ellipsoid(c,[0.25,0.25,0.25],14,10);
      traces.push(surface(e.X, e.Y, e.Z, '#88c999', 0.65, 'Vesicle'));
    });

    // Centrosome (Single)
    const centrosomeC = [-1.7,-2.2,0];
    [[0.8,0,0.25],[0,0.8,-0.25]].forEach(a => {
      traces.push({
        type:'scatter3d',mode:'lines',
        x:[centrosomeC[0]-a[0], centrosomeC[0]+a[0]],
        y:[centrosomeC[1]-a[1], centrosomeC[1]+a[1]],
        z:[centrosomeC[2]-a[2], centrosomeC[2]+a[2]],
        line:{color:'#b48ead',width:6},
        name:'Centrosome',hoverinfo:'name'
      });
    });

    // Cytoskeleton simplified
    function cytFilament(cx,cy,cz,amp,rad,twist,len,color,width,name){
      const curve = t => [
        cx + (rad + amp*Math.sin(t*twist))*Math.cos(t),
        cy + (rad + amp*Math.cos(t*twist))*Math.sin(t),
        cz + 0.6*Math.sin(1.1*t)
      ];
      const pl = polyline3d(curve, 0, len, 160);
      traces.push(lineTrace(pl.X, pl.Y, pl.Z, color, width, name));
    }
    cytFilament(0,0,0,0.6,5.5,2.1,3.5*Math.PI,'#81a1c1',3,'Cytoskeleton');
    cytFilament(-1.5,1.0,0.3,0.5,4.5,2.3,3*Math.PI,'#5e81ac',2,'Cytoskeleton');

    // Ribosomes ~80
    const ribPts = randomPointsInShell(80, NUCLEUS_R+1.3, CELL_R-1.8, [1,0.5,0], NUCLEUS_R+0.7, 505);
    const ribX = ribPts.map(p=>p[0]), ribY = ribPts.map(p=>p[1]), ribZ = ribPts.map(p=>p[2]);
    traces.push({
      type:'scatter3d',mode:'markers',x:ribX,y:ribY,z:ribZ,
      marker:{size:2.4,color:'#434c5e',opacity:0.85},
      name:'Ribosome',hoverinfo:'name    .panel { position:absolute; right:16px; top:90px; width:min(420px,90vw); background:linear-gradient(180deg, rgba(255,255,255,0.08), rgba(255,255,255,0.03)); border:1px solid rgba(255,255,255,0.16); border-radius:16px; padding:16px; z-index:20; backdrop-filter: blur(12px) saturate(130%); box-shadow: 0 12px 48px rgba(0,0,0,0.4), inset 0 0 0 1px rgba(255,255,255,0.06); color:var(--cardText); opacity:0; transform:translateX(100px); pointer-events:none; transition:opacity .4s ease, transform .4s ease; }
    .panel.show { opacity:1; transform:translateX(0); pointer-events:auto; }
    .panel h3 { margin:0 0 8px 0; font-size:20px; font-weight:700; }
    .panel p { margin:8px 0; font-size:14px; line-height:1.6 }
    .panel .hint { font-size:12px; opacity:.8; margin-top:12px; border-top:1px solid rgba(255,255,255,0.1); padding-top:8px; }
    .panel .close { position:absolute; top:8px; right:12px; background:transparent; border:0; color:#fff; font-size:20px; cursor:pointer; opacity:.8; }
    .panel .close:hover { opacity:1 }

    .organelle-viewer { margin-top:12px; height:200px; border:1px solid rgba(255,255,255,0.1); border-radius:12px; background:rgba(0,0,0,0.2); position:relative; overflow:hidden; }
    .organelle-viewer h4 { margin:0 0 8px 0; font-size:14px; opacity:.9; }

    #status { position:absolute; left:12px; bottom:12px; z-index:50; padding:8px 12px; background:rgba(0,0,0,0.7); color:#fff; border-radius:10px; font-size:14px; box-shadow:0 6px 24px rgba(0,0,0,0.4); }
    #status.error { background:#b00020 }
    .hintTop { position:absolute; right:16px; top:60px; z-index:15; font-size:13px; opacity:.9; background:rgba(0,0,0,0.4); color:#fff; padding:8px 12px; border-radius:10px; box-shadow:0 8px 24px rgba(0,0,0,0.3); user-select:none; }

    .intro-text { position:absolute; left:16px; top:120px; max-width:min(380px,86vw); background:linear-gradient(180deg, rgba(255,255,255,0.08), rgba(255,255,255,0.03)); border:1px solid rgba(255,255,255,0.16); border-radius:16px; padding:16px; z-index:15; backdrop-filter: blur(12px) saturate(130%); box-shadow: 0 12px 48px rgba(0,0,0,0.4), inset 0 0 0 1px rgba(255,255,255,0.06); color:var(--cardText); font-size:14px; line-height:1.6; }
  </style>
</head>
<body>
  <div class="banner" aria-live="polite">
    <div class="glow"></div>
    <h1 class="title"><span class="shine">WELCOME TO THE WORLD OF CELL</span></h1>
    <div class="subtitle">Explore a 3D human cell with realistic organelle distribution</div>
    <div class="credit">Made by ANABRATA</div>
  </div>

  <div class="intro-text">
    <strong>About Cells:</strong><br>
    This optimized 3D model shows a typical human cell with realistic organelle numbers and positions. Each organelle type appears in biologically accurate quantities for better performance and educational accuracy.
  </div>

  <div class="hintTop">üñ±Ô∏è Rotate ‚Ä¢ üîç Zoom ‚Ä¢ üëÜ Click organelles for detailed 3D view</div>

  <div id="status">Loading optimized cell...</div>
  <div id="plot" role="img" aria-label="Interactive 3D human cell with labeled organelles"></div>

  <div id="panel" class="panel" aria-live="polite">
    <button class="close" id="closePanel" title="Close">√ó</button>
    <h3 id="orgTitle">Organelle</h3>
    <p id="orgIntro">Click any organelle to explore its structure and function.</p>
    <div class="organelle-viewer">
      <h4 id="viewerTitle">3D Organelle View</h4>
      <div id="organelleViewer" style="width:100%;height:160px;"></div>
    </div>
    <p class="hint">Rotate the 3D view above to examine the organelle structure in detail.</p>
  </div>

  <script>
  (function(){
    const statusEl = document.getElementById('status');
    const panel = document.getElementById('panel');
    const titleEl = document.getElementById('orgTitle');
    const introEl = document.getElementById('orgIntro');
    const viewerTitleEl = document.getElementById('viewerTitle');
    const organelleViewerEl = document.getElementById('organelleViewer');
    document.getElementById('closePanel').addEventListener('click', ()=> panel.classList.remove('show'));

    function fail(msg){
      statusEl.classList.add('error');
      statusEl.textContent = msg;
    }

    // Wait for Plotly
    function waitForPlotly(){
      if (typeof Plotly !== 'undefined') {
        startApp();
      } else {
        setTimeout(waitForPlotly, 100);
      }
    }
    
    if(document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', waitForPlotly);
    } else {
      waitForPlotly();
    }

    function startApp(){
      // Optimized helpers (reduced complexity)
      function linspace(a,b,n){ if(n<2) return [a]; const s=(b-a)/(n-1), arr=new Array(n); for(let i=0;i<n;i++) arr[i]=a+s*i; return arr; }
      function zerosLike2D(M){ const Z=new Array(M.length); for(let i=0;i<M.length;i++){ Z[i]=new Array(M[i].length).fill(0) } return Z; }
      
      // Optimized ellipsoid with fewer polygons
      function ellipsoid(center, radii, nu=24, nv=16){
        const [cx,cy,cz]=center, [rx,ry,rz]=radii;
        const u=linspace(0,2*Math.PI,nu), v=linspace(0,Math.PI,nv);
        const X=new Array(nu), Y=new Array(nu), Z=new Array(nu);
        for(let i=0;i<nu;i++){
          const cu=Math.cos(u[i]), su=Math.sin(u[i]);
          X[i]=new Array(nv); Y[i]=new Array(nv); Z[i]=new Array(nv);
          for(let j=0;j<nv;j++){
            const sv=Math.sin(v[j]), cv=Math.cos(v[j]);
            X[i][j]=rx*cu*sv+cx; Y[i][j]=ry*su*sv+cy; Z[i][j]=rz*cv+cz;
          }
        }
        return {X,Y,Z};
      }
      
      function surface(X,Y,Z,color,opacity,name){
        return {
          type:'surface', x:X,y:Y,z:Z,
          surfacecolor: zerosLike2D(X),
          colorscale: [[0,color],[1,color]],
          showscale:false, opacity:opacity, name:name, hoverinfo:'name',
          lighting:{ambient:.6,diffuse:.6,specular:.3,roughness:.8},
          contours:{
            x:{show:true, color:'rgba(255,255,255,0.06)', width:1},
            y:{show:true, color:'rgba(255,255,255,0.06)', width:1},
            z:{show:false}
          }
        };
      }

      // Realistic random distribution
      function randomPointsInShell(n, inner_r, outer_r, avoid_center, avoid_radius, seed=42){
        Math.seedrandom = function(s) { Math.random = function() { s=Math.sin(s)*10000; return s-Math.floor(s); }; }; Math.seedrandom(seed);
        const pts=[]; let attempts=0;
        while(pts.length<n && attempts<20000){
          const u=Math.random();
          const r=Math.pow((Math.pow(outer_r,3)-Math.pow(inner_r,3))*u + Math.pow(inner_r,3), 1/3);
          const z=Math.random()*2-1, t=Math.random()*2*Math.PI, s=Math.sqrt(1-z*z);
          const x=r*s*Math.cos(t), y=r*s*Math.sin(t), zc=r*z;
          if(avoid_center && typeof avoid_radius==='number'){
            const dx=x-avoid_center[0], dy=y-avoid_center[1], dz=zc-avoid_center[2];
            if(Math.hypot(dx,dy,dz) < avoid_radius){ attempts++; continue; }
          }
          pts.push([x,y,zc]); attempts++;
        }
        Math.random = function() { return crypto.getRandomValues(new Uint32Array(1))[0] / 4294967296; }; // restore
        return pts;
      }

      function polyline3d(curveFn, t0, t1, steps=120){
        const t=linspace(t0,t1,steps), X=new Array(steps),Y=new Array(steps),Z=new Array(steps);
        for(let i=0;i<steps;i++){ const p=curveFn(t[i]); X[i]=p[0]; Y[i]=p[1]; Z[i]=p[2]; }
        return {X,Y,Z};
      }

      function lineTrace(xs,ys,zs,color,width,name){
        return {type:'scatter3d',mode:'lines',x:xs,y:ys,z:zs,line:{color,width},name,hoverinfo:'name',opacity:0.9};
      }

      // Enhanced organelle info
      const INFO = {
        'Cell membrane': 'The phospholipid bilayer that forms the cell boundary. Contains transport proteins, receptors, and maintains cellular integrity.',
        'Cytoplasm': 'The gel-like matrix filling the cell, composed of cytosol and suspended organelles where most cellular metabolism occurs.',
        'Nucleus': 'The control center containing DNA. Regulates gene expression and coordinates protein synthesis, growth, and reproduction.',
        'Nucleolus': 'Dense region within the nucleus responsible for ribosomal RNA synthesis and ribosome assembly.',
        'Mitochondrion': 'The cellular powerhouse generating ATP through oxidative phosphorylation. Contains its own DNA and double membrane.',
        'Golgi apparatus': 'The cellular post office that modifies, packages, and ships proteins from the ER to their final destinations.',
        'Rough ER': 'Membrane network studded with ribosomes, specializing in protein synthesis for secretion and membrane integration.',
        'Smooth ER': 'Ribosome-free ER involved in lipid synthesis, steroid production, calcium storage, and detoxification processes.',
        'Ribosome': 'Protein synthesis machinery translating mRNA into polypeptide chains. Found free or ER-bound.',
        'Lysosome': 'Cellular recycling center containing hydrolytic enzymes that digest worn-out organelles and cellular waste.',
        'Peroxisome': 'Specialized organelle performing oxidative reactions, fatty acid metabolism, and hydrogen peroxide detoxification.',
        'Centrosome': 'Microtubule organizing center containing two centrioles, crucial for cell division and cytoskeleton organization.',
        'Cytoskeleton': 'Dynamic protein framework providing structural support, maintaining cell shape, and enabling organelle transport.',
        'Chromatin': 'DNA-histone complex within the nucleus that condenses into chromosomes during cell division.',
        'Vesicle': 'Small membrane-bound transport containers moving materials between organelles and to the cell surface.'
      };

      // 3D organelle models for detailed viewing
      function create3DOrganelle(name, viewerEl) {
        const traces = [];
        
        switch(name) {
          case 'Mitochondrion':
            // Detailed mitochondrion with cristae
            const outer = ellipsoid([0,0,0],[1.2,0.6,0.6], 32, 20);
            traces.push(surface(outer.X,outer.Y,outer.Z,'#d08770',0.7,'Outer membrane'));
            const inner = ellipsoid([0,0,0],[1.0,0.5,0.5], 28, 16);
            traces.push(surface(inner.X,inner.Y,inner.Z,'#bf616a',0.8,'Inner membrane'));
            // Cristae (internal folds)
            for(let i=0; i<3; i++){
              const cristae = ellipsoid([0.3*Math.sin(i*2.1),0,0.2*Math.cos(i*2.1)],[0.6,0.1,0.3], 20, 10);
              traces.push(surface(cristae.X,cristae.Y,cristae.Z,'#a3be8c',0.9,'Cristae'));
            }
            break;
            
          case 'Nucleus':
            const nucleus = ellipsoid([0,0,0],[1.5,1.4,1.3], 36, 24);
            traces.push(surface(nucleus.X,nucleus.Y,nucleus.Z,'#b48ead',0.5,'Nuclear envelope'));
            const nucleolus = ellipsoid([0.3,0.2,0.1],[0.4,0.4,0.35], 24, 16);
            traces.push(surface(nucleolus.X,nucleolus.Y,nucleolus.Z,'#bf616a',0.85,'Nucleolus'));
            break;
            
          case 'Golgi apparatus':
            // Stacked cisternae
            for(let i=0; i<5; i++){
              const stack = ellipsoid([0.05*i,0.02*i,0],[1.2*(1-i*0.1),0.6*(1-i*0.1),0.15], 28, 12);
              traces.push(surface(stack.X,stack.Y,stack.Z,'#ebcb8b',0.8+i*0.03,'Cisterna '+(i+1)));
            }
            break;
            
          case 'Ribosome':
            // Large and small subunits
            const large = ellipsoid([0,0,0.1],[0.3,0.3,0.25], 20, 14);
            traces.push(surface(large.X,large.Y,large.Z,'#5e81ac',0.9,'Large subunit'));
            const small = ellipsoid([0,0,-0.15],[0.25,0.25,0.2], 18, 12);
            traces.push(surface(small.X,small.Y,small.Z,'#81a1c1',0.9,'Small subunit'));
            break;
            
          case 'Lysosome':
            const lyso = ellipsoid([0,0,0],[0.5,0.5,0.5], 24, 16);
            traces.push(surface(lyso.X,lyso.Y,lyso.Z,'#d08770',0.8,'Lysosomal membrane'));
            break;
            
          default:
            // Generic organelle structure
            const generic = ellipsoid([0,0,0],[0.8,0.8,0.8], 24, 16);
            traces.push(surface(generic.X,generic.Y,generic.Z,'#88c999',0.7,name));
        }

        const layout = {
          scene: { xaxis:{visible:false}, yaxis:{visible:false}, zaxis:{visible:false}, 
                   aspectmode:'data', bgcolor:'rgba(0,0,0,0)',
                   camera:{eye:{x:1.5,y:1.5,z:1.2}} },
          margin:{l:0,r:0,t:0,b:0}, paper_bgcolor:'rgba(0,0,0,0)', showlegend:false
        };

        Plotly.newPlot(viewerEl, traces, layout, {responsive:true, displayModeBar:false});
      }

      function openInfo(name){
        titleEl.textContent = name;
        introEl.textContent = INFO[name] || 'Detailed information about this cellular structure.';
        viewerTitleEl.textContent = name + ' - 3D Structure';
        panel.classList.add('show');
        
        // Create detailed 3D model of clicked organelle
        setTimeout(() => create3DOrganelle(name, organelleViewerEl), 100);
      }

      // Build optimized 3D scene with realistic organelle counts
      const CELL_R=10.0, NUCLEUS_R=3.5, NUCLEOLUS_R=1.2;
      const traces = [];

      // Cytoplasm (optimized)
      const cyto = ellipsoid([0,0,0],[CELL_R*0.98, CELL_R*0.93, CELL_R*0.88], 28, 18);
      traces.push(surface(cyto.X,cyto.Y,cyto.Z,'#4c566a',0.03,'Cytoplasm'));

      // Cell membrane (high quality)
      const membrane = ellipsoid([0,0,0],[CELL_R, CELL_R*0.95, CELL_R*0.90], 48, 28);
      traces.push(surface(membrane.X,membrane.Y,membrane.Z,'#88c999',0.25,'Cell membrane'));

      // Nucleus (single, large)
      const nucleus = ellipsoid([1.0,0.5,0.0],[NUCLEUS_R*1.05, NUCLEUS_R, NUCLEUS_R*0.9], 40, 24);
      traces.push(surface(nucleus.X,nucleus.Y,nucleus.Z,'#b48ead',0.5,'Nucleus'));

      // Nucleolus (single)
      const nucleolus = ellipsoid([1.4,0.8,0.2],[NUCLEOLUS_R, NUCLEOLUS_R, NUCLEOLUS_R*0.9], 32, 20);
      traces.push(surface(nucleolus.X,nucleolus.Y,nucleolus.Z,'#bf616a',0.85,'Nucleolus'));

      // Mitochondria (realistic count: 8-12)
      const mitoCount = 10;
      const mitoCenters = randomPointsInShell(mitoCount, NUCLEUS_R+2.0, CELL_R-2.0, [1.0,0.5,0.0], NUCLEUS_R+1.0, 123);
      for(let i=0; i<mitoCenters.length; i++){
        const e = ellipsoid(mitoCenters[i],[0.9,0.5,0.5], 24, 16);
        traces.push(surface(e.X,e.Y,e.Z,'#d08770',0.85,'Mitochondrion'));
      }

      // Golgi apparatus (single stack)
      const gc=[3.2,-0.8,0.4]; 
      const scales=[1.0,0.9,0.8,0.7,0.6];
      for(let i=0;i<scales.length;i++){
        const s=scales[i], center=[gc[0]+0.12*i, gc[1]+0.03*i, gc[2]];
        const e = ellipsoid(center,[1.6*s,0.75*s,0.18*s], 28, 14);
        traces.push(surface(e.X,e.Y,e.Z,'#ebcb8b',0.9,'Golgi apparatus'));
      }

      // ER network (simplified, realistic)
      function makeER(cx,cy,cz,amp,rad,twist,phase){
        return function(t){
          return [
            cx + (rad + amp*Math.sin(t*twist + phase)) * Math.cos(t),
            cy + (rad + amp*Math.cos(t*twist + phase)) * Math.sin(t),
            cz + 0.4*Math.sin(1.4*t + phase)
          ];
        }
      }
      
      const cent=[1.0,0.5,0.0];
      // Rough ER (2 main branches)
      const roughPhases=[0.0, 1.6];
      for(let i=0;i<roughPhases.length;i++){
        const cx=cent[0]-0.8+0.6*i, cy=cent[1]+0.3*i, cz=cent[2];
        const curve=makeER(cx,cy,cz,0.9,3.5-0.2*i,2.0,roughPhases[i]);
        const pl=polyline3d(curve,0,2*Math.PI,180);
        traces.push(lineTrace(pl.X,pl.Y,pl.Z,'#a3be8c',6,'Rough ER'));
      }
      
      // Smooth ER (1 branch)
      const cx=cent[0]+0.8, cy=cent[1]-0.4, cz=cent[2];
      const smoothCurve=makeER(cx,cy,cz,0.8,3.0,1.8,0.8);
      const smoothPl=polyline3d(smoothCurve,0,2*Math.PI,150);
      traces.push(lineTrace(smoothPl.X,smoothPl.Y,smoothPl.Z,'#8fbcbb',5,'Smooth ER'));

      // Lysosomes (realistic count: 4-6)
      const lysoCenters = randomPointsInShell(5, NUCLEUS_R+1.8, CELL_R-2.0, [1.0,0.5,0.0], NUCLEUS_R+1.0, 456);
      for(const c of lysoCenters){
        const e=ellipsoid(c,[0.4,0.4,0.4], 18, 12);
        traces.push(surface(e.X,e.Y,e.Z,'#d08770',0.75,'Lysosome'));
      }

      // Peroxisomes (realistic count: 2-4)
      const peroxiCenters = randomPointsInShell(3, NUCLEUS_R+1.6, CELL_R-2.0, [1.0,0.5,0.0], NUCLEUS_R+0.9, 789);
      for(const c of peroxiCenters){
        const e=ellipsoid(c,[0.35,0.35,0.35], 18, 12);
        traces.push(surface(e.X,e.Y,e.Z,'#a3be8c',0.78,'Peroxisome'));
      }

      // Transport vesicles (reduced count: 6-8)
      const vesicleCenters = randomPointsInShell(7, NUCLEUS_R+1.4, CELL_R-1.8, [1.0,0.5,0.0], NUCLEUS_R+0.8, 321);
      for(const c of vesicleCenters){
        const e=ellipsoid(c,[0.25,0.25,0.25], 14, 10);
        traces.push(surface(e.X,e.Y,e.Z,'#88c999',0.65,'Vesicle'));
      }

      // Centrosome (single, realistic)
      const c0=[-1.7,-2.2,0.0], a1=[0.8,0.0,0.25], a2=[0.0,0.8,-0.25];
      traces.push({type:'scatter3d',mode:'lines',
                   x:[c0[0]-a1[0],c0[0]+a1[0]],y:[c0[1]-a1[1],c0[1]+a1[1]],z:[c0[2]-a1[2],c0[2]+a1[2]],
                   line:{color:'#b48ead',width:6},name:'Centrosome',hoverinfo:'name'});
      traces.push({type:'scatter3d',mode:'lines',
                   x:[c0[0]-a2[0],c0[0]+a2[0]],y:[c0[1]-a2[1],c0[1]+a2[1]],z:[c0[2]-a2[2],c0[2]+a2[2]],
                   line:{color:'#b48ead',width:6},name:'Centrosome',hoverinfo:'name'});

      // Cytoskeleton (simplified network)
      function cytoskeletonFilament(cx,cy,cz,amp,rad,twist,len,color,width,name){
        const curve=(t)=>[
          cx + (rad + amp*Math.sin(t*twist))*Math.cos(t),
          cy + (rad + amp*Math.cos(t*twist))*Math.sin(t),
          cz + 0.6*Math.sin(1.1*t)
        ];
        const pl=polyline3d(curve,0,len,200);
        traces.push(lineTrace(pl.X,pl.Y,pl.Z,color,width,name));
      }
      cytoskeletonFilament(0,0,0,0.6,5.5,2.1,3.5*Math.PI,'#81a1c1',3,'Cytoskeleton');
      cytoskeletonFilament(-1.5,1.0,0.3,0.5,4.8,2.4,3*Math.PI,'#5e81ac',2,'Cytoskeleton');

      // Ribosomes (realistic distribution: ~80)
      const ribosomePts = randomPointsInShell(80, NUCLEUS_R+1.3, CELL_R-1.8, [1.0,0.5,0.0], NUCLEUS_R+0.7, 654);
      const ribosomeX=ribosomePts.map(p=>p[0]), ribosomeY=ribosomePts.map(p=>p[1]), ribosomeZ=ribosomePts.map(p=>p[2]);
      traces.push({type:'scatter3d',mode:'markers',x:ribosomeX,y:ribosomeY,z:ribosomeZ,
                   marker:{size:2.5,color:'#434c5e',opacity:0.8},
                   name:'Ribosome',hoverinfo:'name'});

      // Optimized rendering settings
      const layout = {
        title: '',
        showlegend:true,
        legend:{orientation:'h', yanchor:'bottom', y:0.02, xanchor:'center', x:0.5, 
                font:{color:'#eceff4', size:12}},
        paper_bgcolor:'rgba(0,0,0,0)',
        margin:{l:0,r:0,t:0,b:0},
        scene:{ 
          xaxis:{visible:false}, yaxis:{visible:false}, zaxis:{visible:false}, 
          aspectmode:'data', 
          camera:{eye:{x:1.8,y:2.0,z:1.2}}, 
          bgcolor:'rgba(0,0,0,0)' 
        }
      };

      // Render with performance optimizations
      const config = {
        responsive:true, 
        displayModeBar:false,
        doubleClick:'reset',
        scrollZoom:true,
        staticPlot:false
      };

      const plotEl = document.getElementById('plot');
      Plotly.newPlot(plotEl, traces, layout, config).then(()=>{
        statusEl.textContent = 'Optimized cell loaded ‚Ä¢ Click organelles for 3D detail view';
        setTimeout(()=>{ statusEl.style.opacity = 0; }, 3000);
      }).catch(e=>{
        statusEl.classList.add('error');
        statusEl.textContent = 'Render error: ' + e.message;
      });

      // Enhanced click handler
      plotEl.on('plotly_click', function(ev){
        if(!ev || !ev.points || !ev.points.length) return;
        const name = ev.points[0].fullData.name || 'Cell structure';
        openInfo(name);
      });

      window.addEventListener('resize', ()=>Plotly.Plots.resize(plotEl));
    }
  })();
  </script>
</body>
</html>
