<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>WELCOME TO THE WORLD OF CELL</title>
  <script src="https://cdn.plot.ly/plotly-2.34.0.min.js"></script>
  <style>
    :root{
      --bg1:#0f1021; --bg2:#1b1e3c; --bg3:#1d3557; --cardText:#e8ecff;
      --accent:#ffd166;
    }
    html, body { height:100%; margin:0; }
    body {
      min-height:100vh; color:#eef2ff;
      font-family: system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;
      overflow:hidden;
      background: radial-gradient(1200px 800px at 20% 10%, #2b2d69 0%, transparent 60%),
                  linear-gradient(135deg, var(--bg1), var(--bg2), var(--bg3));
      background-size: 200% 200%;
      animation: bgPan 20s linear infinite, bgFade 1.8s ease both;
    }
    @keyframes bgPan { 0%{background-position:0% 50%} 50%{background-position:100% 50%} 100%{background-position:0% 50%} }
    @keyframes bgFade { from{opacity:0} to{opacity:1} }

    .banner { position:absolute; top:16px; left:50%; transform:translateX(-50%); text-align:center; z-index:10; padding:8px 12px; user-select:none; pointer-events:none; }
    .title { font-weight:900; letter-spacing:1px; margin:0; font-size:clamp(20px,3.8vw,44px); position:relative; display:inline-block; color:#fff; }
    .title .shine { background: linear-gradient(120deg, #ffffff 5%, #fff7, #ffffff 95%); -webkit-background-clip:text; background-clip:text; color:transparent; background-size:200% 100%; animation: sheen 6s ease-in-out infinite; text-shadow:0 0 18px rgba(255,255,255,0.12); }
    @keyframes sheen { 0%{background-position:200% 0} 50%{background-position:0% 0} 100%{background-position:-200% 0} }
    .subtitle { margin-top:6px; font-size:clamp(12px,1.6vw,16px); opacity:.85; }
    .credit { margin-top:4px; font-size:clamp(12px,1.5vw,15px); color:#c2c8ff; text-shadow: 0 0 10px rgba(255,255,255,0.08); }
    .glow { position:absolute; top:-40px; left:50%; transform:translateX(-50%); width:66vw; height:120px; border-radius:999px; background: radial-gradient(ellipse at center, rgba(255,209,102,0.22), transparent 60%); filter:blur(12px); z-index:1; pointer-events:none; animation:pulse 5.5s ease-in-out infinite; }
    @keyframes pulse { 0%,100%{opacity:.6} 50%{opacity:.95} }

    #plot { width:100vw; height:100vh; }

    .panel { position:absolute; right:16px; top:90px; width:min(420px,90vw); background:linear-gradient(180deg, rgba(255,255,255,0.08), rgba(255,255,255,0.03)); border:1px solid rgba(255,255,255,0.16); border-radius:16px; padding:16px; z-index:20; backdrop-filter: blur(12px) saturate(130%); box-shadow: 0 12px 48px rgba(0,0,0,0.4), inset 0 0 0 1px rgba(255,255,255,0.06); color:var(--cardText); opacity:0; transform:translateX(100px); pointer-events:none; transition:opacity .4s ease, transform .4s ease; }
    .panel.show { opacity:1; transform:translateX(0); pointer-events:auto; }
    .panel h3 { margin:0 0 8px 0; font-size:20px; font-weight:700; }
    .panel p { margin:8px 0; font-size:14px; line-height:1.6 }
    .panel .hint { font-size:12px; opacity:.8; margin-top:12px; border-top:1px solid rgba(255,255,255,0.1); padding-top:8px; }
    .panel .close { position:absolute; top:8px; right:12px; background:transparent; border:0; color:#fff; font-size:20px; cursor:pointer; opacity:.8; }
    .panel .close:hover { opacity:1 }

    .organelle-viewer { margin-top:12px; height:200px; border:1px solid rgba(255,255,255,0.1); border-radius:12px; background:rgba(0,0,0,0.2); position:relative; overflow:hidden; }
    .organelle-viewer h4 { margin:0 0 8px 0; font-size:14px; opacity:.9; }

    #status { position:absolute; left:12px; bottom:12px; z-index:50; padding:8px 12px; background:rgba(0,0,0,0.7); color:#fff; border-radius:10px; font-size:14px; box-shadow:0 6px 24px rgba(0,0,0,0.4); }
    #status.error { background:#b00020 }
    .hintTop { position:absolute; right:16px; top:60px; z-index:15; font-size:13px; opacity:.9; background:rgba(0,0,0,0.4); color:#fff; padding:8px 12px; border-radius:10px; box-shadow:0 8px 24px rgba(0,0,0,0.3); user-select:none; }

    .intro-text { position:absolute; left:16px; top:120px; max-width:min(380px,86vw); background:linear-gradient(180deg, rgba(255,255,255,0.08), rgba(255,255,255,0.03)); border:1px solid rgba(255,255,255,0.16); border-radius:16px; padding:16px; z-index:15; backdrop-filter: blur(12px) saturate(130%); box-shadow: 0 12px 48px rgba(0,0,0,0.4), inset 0 0 0 1px rgba(255,255,255,0.06); color:var(--cardText); font-size:14px; line-height:1.6; }
  </style>
</head>
<body>
  <div class="banner" aria-live="polite">
    <div class="glow"></div>
    <h1 class="title"><span class="shine">WELCOME TO THE WORLD OF CELL</span></h1>
    <div class="subtitle">Explore a 3D human cell with realistic organelle distribution</div>
    <div class="credit">Made by ANABRATA</div>
  </div>

  <div class="intro-text">
    <strong>About Cells:</strong><br>
    This optimized 3D model shows a typical human cell with realistic organelle numbers and positions. Each organelle type appears in biologically accurate quantities for better performance and educational accuracy.
  </div>

  <div class="hintTop">üñ±Ô∏è Rotate ‚Ä¢ üîç Zoom ‚Ä¢ üëÜ Click organelles for detailed 3D view</div>

  <div id="status">Loading optimized cell...</div>
  <div id="plot" role="img" aria-label="Interactive 3D human cell with labeled organelles"></div>

  <div id="panel" class="panel" aria-live="polite">
    <button class="close" id="closePanel" title="Close">√ó</button>
    <h3 id="orgTitle">Organelle</h3>
    <p id="orgIntro">Click any organelle to explore its structure and function.</p>
    <div class="organelle-viewer">
      <h4 id="viewerTitle">3D Organelle View</h4>
      <div id="organelleViewer" style="width:100%;height:160px;"></div>
    </div>
    <p class="hint">Rotate the 3D view above to examine the organelle structure in detail.</p>
  </div>

  <script>
  (function(){
    const statusEl = document.getElementById('status');
    const panel = document.getElementById('panel');
    const titleEl = document.getElementById('orgTitle');
    const introEl = document.getElementById('orgIntro');
    const viewerTitleEl = document.getElementById('viewerTitle');
    const organelleViewerEl = document.getElementById('organelleViewer');
    document.getElementById('closePanel').addEventListener('click', ()=> panel.classList.remove('show'));

    function fail(msg){
      statusEl.classList.add('error');
      statusEl.textContent = msg;
    }

    // Wait for Plotly
    function waitForPlotly(){
      if (typeof Plotly !== 'undefined') {
        startApp();
      } else {
        setTimeout(waitForPlotly, 100);
      }
    }
    
    if(document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', waitForPlotly);
    } else {
      waitForPlotly();
    }

    function startApp(){
      // Optimized helpers (reduced complexity)
      function linspace(a,b,n){ if(n<2) return [a]; const s=(b-a)/(n-1), arr=new Array(n); for(let i=0;i<n;i++) arr[i]=a+s*i; return arr; }
      function zerosLike2D(M){ const Z=new Array(M.length); for(let i=0;i<M.length;i++){ Z[i]=new Array(M[i].length).fill(0) } return Z; }
      
      // Optimized ellipsoid with fewer polygons
      function ellipsoid(center, radii, nu=24, nv=16){
        const [cx,cy,cz]=center, [rx,ry,rz]=radii;
        const u=linspace(0,2*Math.PI,nu), v=linspace(0,Math.PI,nv);
        const X=new Array(nu), Y=new Array(nu), Z=new Array(nu);
        for(let i=0;i<nu;i++){
          const cu=Math.cos(u[i]), su=Math.sin(u[i]);
          X[i]=new Array(nv); Y[i]=new Array(nv); Z[i]=new Array(nv);
          for(let j=0;j<nv;j++){
            const sv=Math.sin(v[j]), cv=Math.cos(v[j]);
            X[i][j]=rx*cu*sv+cx; Y[i][j]=ry*su*sv+cy; Z[i][j]=rz*cv+cz;
          }
        }
        return {X,Y,Z};
      }
      
      function surface(X,Y,Z,color,opacity,name){
        return {
          type:'surface', x:X,y:Y,z:Z,
          surfacecolor: zerosLike2D(X),
          colorscale: [[0,color],[1,color]],
          showscale:false, opacity:opacity, name:name, hoverinfo:'name',
          lighting:{ambient:.6,diffuse:.6,specular:.3,roughness:.8},
          contours:{
            x:{show:true, color:'rgba(255,255,255,0.06)', width:1},
            y:{show:true, color:'rgba(255,255,255,0.06)', width:1},
            z:{show:false}
          }
        };
      }

      // Realistic random distribution
      function randomPointsInShell(n, inner_r, outer_r, avoid_center, avoid_radius, seed=42){
        Math.seedrandom = function(s) { Math.random = function() { s=Math.sin(s)*10000; return s-Math.floor(s); }; }; Math.seedrandom(seed);
        const pts=[]; let attempts=0;
        while(pts.length<n && attempts<20000){
          const u=Math.random();
          const r=Math.pow((Math.pow(outer_r,3)-Math.pow(inner_r,3))*u + Math.pow(inner_r,3), 1/3);
          const z=Math.random()*2-1, t=Math.random()*2*Math.PI, s=Math.sqrt(1-z*z);
          const x=r*s*Math.cos(t), y=r*s*Math.sin(t), zc=r*z;
          if(avoid_center && typeof avoid_radius==='number'){
            const dx=x-avoid_center[0], dy=y-avoid_center[1], dz=zc-avoid_center[2];
            if(Math.hypot(dx,dy,dz) < avoid_radius){ attempts++; continue; }
          }
          pts.push([x,y,zc]); attempts++;
        }
        Math.random = function() { return crypto.getRandomValues(new Uint32Array(1))[0] / 4294967296; }; // restore
        return pts;
      }

      function polyline3d(curveFn, t0, t1, steps=120){
        const t=linspace(t0,t1,steps), X=new Array(steps),Y=new Array(steps),Z=new Array(steps);
        for(let i=0;i<steps;i++){ const p=curveFn(t[i]); X[i]=p[0]; Y[i]=p[1]; Z[i]=p[2]; }
        return {X,Y,Z};
      }

      function lineTrace(xs,ys,zs,color,width,name){
        return {type:'scatter3d',mode:'lines',x:xs,y:ys,z:zs,line:{color,width},name,hoverinfo:'name',opacity:0.9};
      }

      // Enhanced organelle info
      const INFO = {
        'Cell membrane': 'The phospholipid bilayer that forms the cell boundary. Contains transport proteins, receptors, and maintains cellular integrity.',
        'Cytoplasm': 'The gel-like matrix filling the cell, composed of cytosol and suspended organelles where most cellular metabolism occurs.',
        'Nucleus': 'The control center containing DNA. Regulates gene expression and coordinates protein synthesis, growth, and reproduction.',
        'Nucleolus': 'Dense region within the nucleus responsible for ribosomal RNA synthesis and ribosome assembly.',
        'Mitochondrion': 'The cellular powerhouse generating ATP through oxidative phosphorylation. Contains its own DNA and double membrane.',
        'Golgi apparatus': 'The cellular post office that modifies, packages, and ships proteins from the ER to their final destinations.',
        'Rough ER': 'Membrane network studded with ribosomes, specializing in protein synthesis for secretion and membrane integration.',
        'Smooth ER': 'Ribosome-free ER involved in lipid synthesis, steroid production, calcium storage, and detoxification processes.',
        'Ribosome': 'Protein synthesis machinery translating mRNA into polypeptide chains. Found free or ER-bound.',
        'Lysosome': 'Cellular recycling center containing hydrolytic enzymes that digest worn-out organelles and cellular waste.',
        'Peroxisome': 'Specialized organelle performing oxidative reactions, fatty acid metabolism, and hydrogen peroxide detoxification.',
        'Centrosome': 'Microtubule organizing center containing two centrioles, crucial for cell division and cytoskeleton organization.',
        'Cytoskeleton': 'Dynamic protein framework providing structural support, maintaining cell shape, and enabling organelle transport.',
        'Chromatin': 'DNA-histone complex within the nucleus that condenses into chromosomes during cell division.',
        'Vesicle': 'Small membrane-bound transport containers moving materials between organelles and to the cell surface.'
      };

      // 3D organelle models for detailed viewing
      function create3DOrganelle(name, viewerEl) {
        const traces = [];
        
        switch(name) {
          case 'Mitochondrion':
            // Detailed mitochondrion with cristae
            const outer = ellipsoid([0,0,0],[1.2,0.6,0.6], 32, 20);
            traces.push(surface(outer.X,outer.Y,outer.Z,'#d08770',0.7,'Outer membrane'));
            const inner = ellipsoid([0,0,0],[1.0,0.5,0.5], 28, 16);
            traces.push(surface(inner.X,inner.Y,inner.Z,'#bf616a',0.8,'Inner membrane'));
            // Cristae (internal folds)
            for(let i=0; i<3; i++){
              const cristae = ellipsoid([0.3*Math.sin(i*2.1),0,0.2*Math.cos(i*2.1)],[0.6,0.1,0.3], 20, 10);
              traces.push(surface(cristae.X,cristae.Y,cristae.Z,'#a3be8c',0.9,'Cristae'));
            }
            break;
            
          case 'Nucleus':
            const nucleus = ellipsoid([0,0,0],[1.5,1.4,1.3], 36, 24);
            traces.push(surface(nucleus.X,nucleus.Y,nucleus.Z,'#b48ead',0.5,'Nuclear envelope'));
            const nucleolus = ellipsoid([0.3,0.2,0.1],[0.4,0.4,0.35], 24, 16);
            traces.push(surface(nucleolus.X,nucleolus.Y,nucleolus.Z,'#bf616a',0.85,'Nucleolus'));
            break;
            
          case 'Golgi apparatus':
            // Stacked cisternae
            for(let i=0; i<5; i++){
              const stack = ellipsoid([0.05*i,0.02*i,0],[1.2*(1-i*0.1),0.6*(1-i*0.1),0.15], 28, 12);
              traces.push(surface(stack.X,stack.Y,stack.Z,'#ebcb8b',0.8+i*0.03,'Cisterna '+(i+1)));
            }
            break;
            
          case 'Ribosome':
            // Large and small subunits
            const large = ellipsoid([0,0,0.1],[0.3,0.3,0.25], 20, 14);
            traces.push(surface(large.X,large.Y,large.Z,'#5e81ac',0.9,'Large subunit'));
            const small = ellipsoid([0,0,-0.15],[0.25,0.25,0.2], 18, 12);
            traces.push(surface(small.X,small.Y,small.Z,'#81a1c1',0.9,'Small subunit'));
            break;
            
          case 'Lysosome':
            const lyso = ellipsoid([0,0,0],[0.5,0.5,0.5], 24, 16);
            traces.push(surface(lyso.X,lyso.Y,lyso.Z,'#d08770',0.8,'Lysosomal membrane'));
            break;
            
          default:
            // Generic organelle structure
            const generic = ellipsoid([0,0,0],[0.8,0.8,0.8], 24, 16);
            traces.push(surface(generic.X,generic.Y,generic.Z,'#88c999',0.7,name));
        }

        const layout = {
          scene: { xaxis:{visible:false}, yaxis:{visible:false}, zaxis:{visible:false}, 
                   aspectmode:'data', bgcolor:'rgba(0,0,0,0)',
                   camera:{eye:{x:1.5,y:1.5,z:1.2}} },
          margin:{l:0,r:0,t:0,b:0}, paper_bgcolor:'rgba(0,0,0,0)', showlegend:false
        };

        Plotly.newPlot(viewerEl, traces, layout, {responsive:true, displayModeBar:false});
      }

      function openInfo(name){
        titleEl.textContent = name;
        introEl.textContent = INFO[name] || 'Detailed information about this cellular structure.';
        viewerTitleEl.textContent = name + ' - 3D Structure';
        panel.classList.add('show');
        
        // Create detailed 3D model of clicked organelle
        setTimeout(() => create3DOrganelle(name, organelleViewerEl), 100);
      }

      // Build optimized 3D scene with realistic organelle counts
      const CELL_R=10.0, NUCLEUS_R=3.5, NUCLEOLUS_R=1.2;
      const traces = [];

      // Cytoplasm (optimized)
      const cyto = ellipsoid([0,0,0],[CELL_R*0.98, CELL_R*0.93, CELL_R*0.88], 28, 18);
      traces.push(surface(cyto.X,cyto.Y,cyto.Z,'#4c566a',0.03,'Cytoplasm'));

      // Cell membrane (high quality)
      const membrane = ellipsoid([0,0,0],[CELL_R, CELL_R*0.95, CELL_R*0.90], 48, 28);
      traces.push(surface(membrane.X,membrane.Y,membrane.Z,'#88c999',0.25,'Cell membrane'));

      // Nucleus (single, large)
      const nucleus = ellipsoid([1.0,0.5,0.0],[NUCLEUS_R*1.05, NUCLEUS_R, NUCLEUS_R*0.9], 40, 24);
      traces.push(surface(nucleus.X,nucleus.Y,nucleus.Z,'#b48ead',0.5,'Nucleus'));

      // Nucleolus (single)
      const nucleolus = ellipsoid([1.4,0.8,0.2],[NUCLEOLUS_R, NUCLEOLUS_R, NUCLEOLUS_R*0.9], 32, 20);
      traces.push(surface(nucleolus.X,nucleolus.Y,nucleolus.Z,'#bf616a',0.85,'Nucleolus'));

      // Mitochondria (realistic count: 8-12)
      const mitoCount = 10;
      const mitoCenters = randomPointsInShell(mitoCount, NUCLEUS_R+2.0, CELL_R-2.0, [1.0,0.5,0.0], NUCLEUS_R+1.0, 123);
      for(let i=0; i<mitoCenters.length; i++){
        const e = ellipsoid(mitoCenters[i],[0.9,0.5,0.5], 24, 16);
        traces.push(surface(e.X,e.Y,e.Z,'#d08770',0.85,'Mitochondrion'));
      }

      // Golgi apparatus (single stack)
      const gc=[3.2,-0.8,0.4]; 
      const scales=[1.0,0.9,0.8,0.7,0.6];
      for(let i=0;i<scales.length;i++){
        const s=scales[i], center=[gc[0]+0.12*i, gc[1]+0.03*i, gc[2]];
        const e = ellipsoid(center,[1.6*s,0.75*s,0.18*s], 28, 14);
        traces.push(surface(e.X,e.Y,e.Z,'#ebcb8b',0.9,'Golgi apparatus'));
      }

      // ER network (simplified, realistic)
      function makeER(cx,cy,cz,amp,rad,twist,phase){
        return function(t){
          return [
            cx + (rad + amp*Math.sin(t*twist + phase)) * Math.cos(t),
            cy + (rad + amp*Math.cos(t*twist + phase)) * Math.sin(t),
            cz + 0.4*Math.sin(1.4*t + phase)
          ];
        }
      }
      
      const cent=[1.0,0.5,0.0];
      // Rough ER (2 main branches)
      const roughPhases=[0.0, 1.6];
      for(let i=0;i<roughPhases.length;i++){
        const cx=cent[0]-0.8+0.6*i, cy=cent[1]+0.3*i, cz=cent[2];
        const curve=makeER(cx,cy,cz,0.9,3.5-0.2*i,2.0,roughPhases[i]);
        const pl=polyline3d(curve,0,2*Math.PI,180);
        traces.push(lineTrace(pl.X,pl.Y,pl.Z,'#a3be8c',6,'Rough ER'));
      }
      
      // Smooth ER (1 branch)
      const cx=cent[0]+0.8, cy=cent[1]-0.4, cz=cent[2];
      const smoothCurve=makeER(cx,cy,cz,0.8,3.0,1.8,0.8);
      const smoothPl=polyline3d(smoothCurve,0,2*Math.PI,150);
      traces.push(lineTrace(smoothPl.X,smoothPl.Y,smoothPl.Z,'#8fbcbb',5,'Smooth ER'));

      // Lysosomes (realistic count: 4-6)
      const lysoCenters = randomPointsInShell(5, NUCLEUS_R+1.8, CELL_R-2.0, [1.0,0.5,0.0], NUCLEUS_R+1.0, 456);
      for(const c of lysoCenters){
        const e=ellipsoid(c,[0.4,0.4,0.4], 18, 12);
        traces.push(surface(e.X,e.Y,e.Z,'#d08770',0.75,'Lysosome'));
      }

      // Peroxisomes (realistic count: 2-4)
      const peroxiCenters = randomPointsInShell(3, NUCLEUS_R+1.6, CELL_R-2.0, [1.0,0.5,0.0], NUCLEUS_R+0.9, 789);
      for(const c of peroxiCenters){
        const e=ellipsoid(c,[0.35,0.35,0.35], 18, 12);
        traces.push(surface(e.X,e.Y,e.Z,'#a3be8c',0.78,'Peroxisome'));
      }

      // Transport vesicles (reduced count: 6-8)
      const vesicleCenters = randomPointsInShell(7, NUCLEUS_R+1.4, CELL_R-1.8, [1.0,0.5,0.0], NUCLEUS_R+0.8, 321);
      for(const c of vesicleCenters){
        const e=ellipsoid(c,[0.25,0.25,0.25], 14, 10);
        traces.push(surface(e.X,e.Y,e.Z,'#88c999',0.65,'Vesicle'));
      }

      // Centrosome (single, realistic)
      const c0=[-1.7,-2.2,0.0], a1=[0.8,0.0,0.25], a2=[0.0,0.8,-0.25];
      traces.push({type:'scatter3d',mode:'lines',
                   x:[c0[0]-a1[0],c0[0]+a1[0]],y:[c0[1]-a1[1],c0[1]+a1[1]],z:[c0[2]-a1[2],c0[2]+a1[2]],
                   line:{color:'#b48ead',width:6},name:'Centrosome',hoverinfo:'name'});
      traces.push({type:'scatter3d',mode:'lines',
                   x:[c0[0]-a2[0],c0[0]+a2[0]],y:[c0[1]-a2[1],c0[1]+a2[1]],z:[c0[2]-a2[2],c0[2]+a2[2]],
                   line:{color:'#b48ead',width:6},name:'Centrosome',hoverinfo:'name'});

      // Cytoskeleton (simplified network)
      function cytoskeletonFilament(cx,cy,cz,amp,rad,twist,len,color,width,name){
        const curve=(t)=>[
          cx + (rad + amp*Math.sin(t*twist))*Math.cos(t),
          cy + (rad + amp*Math.cos(t*twist))*Math.sin(t),
          cz + 0.6*Math.sin(1.1*t)
        ];
        const pl=polyline3d(curve,0,len,200);
        traces.push(lineTrace(pl.X,pl.Y,pl.Z,color,width,name));
      }
      cytoskeletonFilament(0,0,0,0.6,5.5,2.1,3.5*Math.PI,'#81a1c1',3,'Cytoskeleton');
      cytoskeletonFilament(-1.5,1.0,0.3,0.5,4.8,2.4,3*Math.PI,'#5e81ac',2,'Cytoskeleton');

      // Ribosomes (realistic distribution: ~80)
      const ribosomePts = randomPointsInShell(80, NUCLEUS_R+1.3, CELL_R-1.8, [1.0,0.5,0.0], NUCLEUS_R+0.7, 654);
      const ribosomeX=ribosomePts.map(p=>p[0]), ribosomeY=ribosomePts.map(p=>p[1]), ribosomeZ=ribosomePts.map(p=>p[2]);
      traces.push({type:'scatter3d',mode:'markers',x:ribosomeX,y:ribosomeY,z:ribosomeZ,
                   marker:{size:2.5,color:'#434c5e',opacity:0.8},
                   name:'Ribosome',hoverinfo:'name'});

      // Optimized rendering settings
      const layout = {
        title: '',
        showlegend:true,
        legend:{orientation:'h', yanchor:'bottom', y:0.02, xanchor:'center', x:0.5, 
                font:{color:'#eceff4', size:12}},
        paper_bgcolor:'rgba(0,0,0,0)',
        margin:{l:0,r:0,t:0,b:0},
        scene:{ 
          xaxis:{visible:false}, yaxis:{visible:false}, zaxis:{visible:false}, 
          aspectmode:'data', 
          camera:{eye:{x:1.8,y:2.0,z:1.2}}, 
          bgcolor:'rgba(0,0,0,0)' 
        }
      };

      // Render with performance optimizations
      const config = {
        responsive:true, 
        displayModeBar:false,
        doubleClick:'reset',
        scrollZoom:true,
        staticPlot:false
      };

      const plotEl = document.getElementById('plot');
      Plotly.newPlot(plotEl, traces, layout, config).then(()=>{
        statusEl.textContent = 'Optimized cell loaded ‚Ä¢ Click organelles for 3D detail view';
        setTimeout(()=>{ statusEl.style.opacity = 0; }, 3000);
      }).catch(e=>{
        statusEl.classList.add('error');
        statusEl.textContent = 'Render error: ' + e.message;
      });

      // Enhanced click handler
      plotEl.on('plotly_click', function(ev){
        if(!ev || !ev.points || !ev.points.length) return;
        const name = ev.points[0].fullData.name || 'Cell structure';
        openInfo(name);
      });

      window.addEventListener('resize', ()=>Plotly.Plots.resize(plotEl));
    }
  })();
  </script>
</body>
</html>
