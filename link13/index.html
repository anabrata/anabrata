# 3D Human Cell - schematic Plotly visualization
# Requires: pip install plotly numpy

import numpy as np
import plotly.graph_objects as go

# -------------- geometry helpers --------------

def ellipsoid(center, radii, nu=50, nv=30):
    """
    Create parametric mesh grids for an ellipsoid surface.
    center: (cx, cy, cz)
    radii: (rx, ry, rz)
    returns: X, Y, Z arrays of shape (nu, nv)
    """
    u = np.linspace(0, 2*np.pi, nu)
    v = np.linspace(0, np.pi, nv)
    cu, su = np.cos(u), np.sin(u)
    sv, cv = np.sin(v), np.cos(v)
    X = radii[0] * np.outer(cu, sv) + center[0]
    Y = radii[1] * np.outer(su, sv) + center[1]
    Z = radii[2] * np.outer(np.ones_like(u), cv) + center[2]
    return X, Y, Z

def surface_trace(X, Y, Z, color="#cccccc", opacity=1.0, name="", showscale=False):
    # Use a flat colorscale to simulate a solid color
    # surfacecolor just needs to be same-shape array
    C = np.zeros_like(X)
    return go.Surface(
        x=X, y=Y, z=Z,
        surfacecolor=C,
        colorscale=[[0, color], [1, color]],
        showscale=showscale,
        opacity=opacity,
        name=name,
        hoverinfo="name",
        lighting=dict(ambient=0.5, diffuse=0.5, specular=0.2, roughness=0.9),
    )

def random_points_in_shell(n, inner_r, outer_r, avoid_center=None, avoid_radius=None, seed=0):
    """
    Uniform random points inside a spherical shell between inner_r and outer_r.
    If avoid_center and avoid_radius provided, reject points that fall inside that sphere.
    """
    rng = np.random.default_rng(seed)
    pts = []
    attempts = 0
    while len(pts) < n and attempts < 10000:
        # sample radius with r^3 distribution for uniform volume
        u = rng.random()
        r = ((outer_r**3 - inner_r**3)*u + inner_r**3) ** (1/3)
        # random direction
        z = rng.uniform(-1, 1)
        t = rng.uniform(0, 2*np.pi)
        s = np.sqrt(1 - z*z)
        x = r * s * np.cos(t)
        y = r * s * np.sin(t)
        zc = r * z
        if avoid_center is not None and avoid_radius is not None:
            if np.linalg.norm(np.array([x, y, zc]) - np.array(avoid_center)) < avoid_radius:
                attempts += 1
                continue
        pts.append((x, y, zc))
        attempts += 1
    return np.array(pts)

def polyline3d(curve_fn, t0, t1, steps):
    t = np.linspace(t0, t1, steps)
    xyz = np.array([curve_fn(tt) for tt in t])
    return xyz[:,0], xyz[:,1], xyz[:,2]

# -------------- scene constants --------------

# Overall cell size (arbitrary units)
CELL_R = 10.0
NUCLEUS_R = 3.5
NUCLEOLUS_R = 1.2

# -------------- build organelles --------------

traces = []

# Cell membrane (semi-transparent sphere)
Xm, Ym, Zm = ellipsoid(center=(0,0,0), radii=(CELL_R, CELL_R*0.95, CELL_R*0.9), nu=80, nv=40)
traces.append(surface_trace(Xm, Ym, Zm, color="#8ecae6", opacity=0.18, name="Cell membrane"))

# Nucleus
Xn, Yn, Zn = ellipsoid(center=(1.0, 0.5, 0.0), radii=(NUCLEUS_R*1.05, NUCLEUS_R, NUCLEUS_R*0.9), nu=60, nv=36)
traces.append(surface_trace(Xn, Yn, Zn, color="#bdb2ff", opacity=0.45, name="Nucleus"))

# Nucleolus
Xnu, Ynu, Znu = ellipsoid(center=(1.4, 0.8, 0.2), radii=(NUCLEOLUS_R, NUCLEOLUS_R, NUCLEOLUS_R*0.9), nu=50, nv=30)
traces.append(surface_trace(Xnu, Ynu, Znu, color="#ffadad", opacity=0.85, name="Nucleolus"))

# Mitochondria (multiple small ellipsoids distributed in cytoplasm, avoiding nucleus)
mito_centers = random_points_in_shell(
    n=14,
    inner_r=NUCLEUS_R + 2.0,
    outer_r=CELL_R - 2.0,
    avoid_center=(1.0, 0.5, 0.0),
    avoid_radius=NUCLEUS_R + 1.0,
    seed=42
)

for (mx, my, mz) in mito_centers:
    rx, ry, rz = 0.8, 0.45, 0.45
    Xmi, Ymi, Zmi = ellipsoid(center=(mx, my, mz), radii=(rx, ry, rz), nu=28, nv=18)
    traces.append(surface_trace(Xmi, Ymi, Zmi, color="#fb8500", opacity=0.9, name="Mitochondrion"))

# Golgi apparatus (stack of flattened ellipsoids near nucleus)
golgi_center = (3.2, -0.8, 0.4)
for i, shrink in enumerate([1.0, 0.9, 0.8, 0.7, 0.6]):
    Xg, Yg, Zg = ellipsoid(
        center=(golgi_center[0] + 0.15*i, golgi_center[1] + 0.05*i, golgi_center[2]),
        radii=(1.8*shrink, 0.8*shrink, 0.25*shrink),
        nu=40, nv=20
    )
    traces.append(surface_trace(Xg, Yg, Zg, color="#ffd166", opacity=0.95, name="Golgi stack"))

# Endoplasmic reticulum (meandering polylines near nucleus)
def make_er_curve(cx, cy, cz, amp=1.1, rad=4.5, twist=2.2, phase=0.0):
    def curve(t):
        # toroidal-ish meander around nucleus offset
        x = cx + (rad + amp*np.sin(t*twist + phase)) * np.cos(t)
        y = cy + (rad + amp*np.cos(t*twist + phase)) * np.sin(t)
        z = cz + 0.5*np.sin(1.5*t + phase)
        return np.array([x, y, z])
    return curve

er_colors = ["#2a9d8f", "#2a9d8f", "#2a9d8f"]
cent = (1.0, 0.5, 0.0)
for idx, ph in enumerate([0.0, 0.9, 1.8]):
    cx = cent[0] - 0.8 + 0.4*idx
    cy = cent[1] + 0.2*idx
    cz = cent[2]
    curve_fn = make_er_curve(cx, cy, cz, amp=1.0, rad=4.0-0.4*idx, twist=2.0, phase=ph)
    Xc, Yc, Zc = polyline3d(curve_fn, 0, 2*np.pi, steps=400)
    traces.append(go.Scatter3d(
        x=Xc, y=Yc, z=Zc,
        mode="lines",
        line=dict(color=er_colors[idx], width=5),
        name="Endoplasmic reticulum",
        hoverinfo="name",
        opacity=0.9
    ))

# Ribosomes (small points, enriched near ER and cytosol)
ribos = random_points_in_shell(
    n=450,
    inner_r=NUCLEUS_R + 1.2,
    outer_r=CELL_R - 1.5,
    avoid_center=(1.0, 0.5, 0.0),
    avoid_radius=NUCLEUS_R + 0.6,
    seed=7
)
traces.append(go.Scatter3d(
    x=ribos[:,0], y=ribos[:,1], z=ribos[:,2],
    mode="markers",
    marker=dict(size=2, color="#264653", opacity=0.8),
    name="Ribosomes",
    hoverinfo="name"
))

# Lysosomes / vesicles (small spheres)
ves_centers = random_points_in_shell(
    n=18,
    inner_r=NUCLEUS_R + 1.5,
    outer_r=CELL_R - 2.0,
    avoid_center=(1.0, 0.5, 0.0),
    avoid_radius=NUCLEUS_R + 0.8,
    seed=21
)
for (vx, vy, vz) in ves_centers:
    Xv, Yv, Zv = ellipsoid(center=(vx, vy, vz), radii=(0.35, 0.35, 0.35), nu=20, nv=14)
    traces.append(surface_trace(Xv, Yv, Zv, color="#90be6d", opacity=0.65, name="Vesicle"))

# Centrosome (two short orthogonal microtubule bundles near nucleus)
c0 = np.array([ -1.5, -2.0, 0.0 ])
axis1 = np.array([0.8, 0.0, 0.2])
axis2 = np.array([0.0, 0.8, -0.2])

def segment_trace(p0, p1, color, name):
    return go.Scatter3d(
        x=[p0[0], p1[0]], y=[p0[1], p1[1]], z=[p0[2], p1[2]],
        mode="lines",
        line=dict(color=color, width=6),
        name=name,
        hoverinfo="name"
    )

traces.append(segment_trace(c0 - axis1, c0 + axis1, "#6a4c93", "Centrosome"))
traces.append(segment_trace(c0 - axis2, c0 + axis2, "#6a4c93", "Centrosome"))

# -------------- assemble scene --------------

fig = go.Figure(data=traces)

fig.update_scenes(
    xaxis=dict(visible=False),
    yaxis=dict(visible=False),
    zaxis=dict(visible=False),
    aspectmode="data",
    camera=dict(eye=dict(x=1.6, y=1.8, z=1.1)),
)

fig.update_layout(
    title="Schematic 3D Human (Animal) Cell",
    showlegend=True,
    legend=dict(orientation="h", yanchor="bottom", y=0.02, xanchor="center", x=0.5),
    margin=dict(l=0, r=0, t=40, b=0),
    paper_bgcolor="white",
)

fig.show()
