<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Focus Timer</title>
  <meta name="description" content="Timer with flip clock and real-time mode." />
  <style>
    /* ====== Base styles (existing) ====== */
    html, body { height: 100%; }
    body {
      margin: 0;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji";
      color: #e8eef6;
      background:
        radial-gradient(1100px 700px at 10% 0%, #1b2340 0%, transparent 65%),
        radial-gradient(1100px 700px at 90% 0%, #013a39 0%, transparent 65%),
        linear-gradient(180deg, #0a0d12 0%, #0e1116 100%);
      -webkit-font-smoothing: antialiased;
      -moz-osx-font-smoothing: grayscale;
    }

    /* Layout shells (examples; keep existing structure) */
    header, nav, .controls, .todo-wrapper, .candle-wrapper, .music, .footer, .side-panels, .extras, .total {
      /* existing styles in your app */
    }

    .clock-container {
      /* ensure there is a container that wraps either flip or plain clock */
      display: grid;
      place-items: center;
      padding: 20px;
      min-height: 40vh;
    }

    .clock {
      font-weight: 800;
      font-variant-numeric: tabular-nums;
      font-size: clamp(36px, 8vw, 96px);
      letter-spacing: 0.02em;
    }

    .flip-clock {
      /* your flip clock container; keep your existing flip styles */
      font-variant-numeric: tabular-nums;
      font-size: clamp(28px, 6.5vw, 72px);
    }

    /* ====== NEW: Real-time mode isolation ====== */
    /* When Real Time is active, hide everything except background and clock */
    body[data-mode="realtime"] header,
    body[data-mode="realtime"] nav,
    body[data-mode="realtime"] .controls,
    body[data-mode="realtime"] .todo,
    body[data-mode="realtime"] .todo-wrapper,
    body[data-mode="realtime"] .total,
    body[data-mode="realtime"] .music,
    body[data-mode="realtime"] .footer,
    body[data-mode="realtime"] .side-panels,
    body[data-mode="realtime"] .extras,
    body[data-mode="realtime"] .candle,
    body[data-mode="realtime"] .candle-wrapper {
      display: none !important;
    }

    /* Center the clock cleanly in the viewport for Real Time */
    body[data-mode="realtime"] .clock-container {
      position: fixed;
      inset: 0;
      display: grid;
      place-items: center;
      margin: 0;
      padding: 0;
    }

    /* Keep transforms stable */
    body[data-mode="realtime"] .clock,
    body[data-mode="realtime"] .flip-clock {
      transform: translateZ(0);
    }

    /* ====== Minimal utility for demo layout (optional) ====== */
    .toolbar {
      display: flex;
      gap: 12px;
      align-items: center;
      padding: 12px 16px;
    }
    label { font-size: 14px; color: #b8c2d4; }
    select, input[type="checkbox"] {
      background: #101827;
      color: #e8eef6;
      border: 1px solid #2a3856;
      border-radius: 8px;
      padding: 8px 10px;
      outline: none;
    }
    .page {
      max-width: 980px;
      margin: 0 auto;
      padding: 20px;
    }
  </style>
</head>
<body>
  <!-- Example header/controls (keep your own; IDs/classes referenced by JS should exist) -->
  <header>
    <div class="page">
      <div class="toolbar">
        <label for="timeMode">Time mode</label>
        <select id="timeMode">
          <!-- Keep existing options intact; just add Real Time -->
          <option value="pomodoro">Pomodoro</option>
          <option value="countdown">Countdown</option>
          <option value="countup">Count Up</option>
          <!-- NEW: Real Time -->
          <option value="realtime">Real Time</option>
        </select>

        <label for="flipToggle" style="margin-left: 10px; display:flex; align-items:center; gap:8px;">
          <input id="flipToggle" type="checkbox" />
          Flip style
        </label>
      </div>
    </div>
  </header>

  <!-- Candle/other UI wrappers in real app -->
  <div class="candle-wrapper">
    <div class="page">
      <div class="candle"><!-- your candle canvas/DOM lives here --></div>
    </div>
  </div>

  <!-- Clock area -->
  <main>
    <div class="page">
      <div class="clock-container">
        <!-- Plain clock text (non-flip). Keep in DOM; we toggle visibility. -->
        <div class="clock" id="plainClock">00:00:00</div>

        <!-- Flip clock container. Replace internals with your existing flip DOM. -->
        <div class="flip-clock" id="flipClock" style="display:none;">
          <!-- Example label node to receive text if no specific digit API is present -->
          <div class="flip-label" data-flip-label>00:00:00</div>
        </div>
      </div>
    </div>
  </main>

  <!-- Other app sections -->
  <section class="todo-wrapper">
    <div class="page">
      <div class="todo"><!-- your todo UI --></div>
    </div>
  </section>

  <section class="extras">
    <div class="page">
      <div class="total"><!-- totals --></div>
      <div class="music"><!-- music --></div>
      <div class="side-panels"><!-- side panels --></div>
    </div>
  </section>

  <footer class="footer">
    <div class="page">Footer</div>
  </footer>

  <script>
    (function(){
      // Grab elements
      const timeModeEl = document.getElementById('timeMode');
      const flipToggle = document.getElementById('flipToggle');
      const bodyEl = document.body;

      // Clocks
      const flipClockEl = document.getElementById('flipClock');
      const plainClockEl = document.getElementById('plainClock');

      // Existing timer safe pauses (no-op if not present)
      const pauseTimerSafely = () => {
        try { window.timer && window.timer.pause && window.timer.pause(); } catch(e){}
        try { window.stopTimer && window.stopTimer(); } catch(e){}
      };

      // Flip style predicate (use your real app state if different)
      const isFlipEnabled = () => flipToggle ? flipToggle.checked : !!document.querySelector('.flip-clock');

      // Real-time loop state
      let realtimeTimeout = null;
      let lastRendered = '';

      function pad(n){ return n < 10 ? '0' + n : '' + n; }
      function nowText() {
        const d = new Date();
        return pad(d.getHours()) + ':' + pad(d.getMinutes()) + ':' + pad(d.getSeconds());
      }

      function renderPlain(text) {
        if (plainClockEl) plainClockEl.textContent = text;
      }

      function renderFlip(text) {
        if (!flipClockEl) return;
        // If your app has a dedicated flip API, call it here instead.
        flipClockEl.setAttribute('data-time', text);
        const label = flipClockEl.querySelector('[data-flip-label]') || flipClockEl.querySelector('.flip-label');
        if (label) label.textContent = text;
      }

      function drawNow() {
        const t = nowText();
        if (t !== lastRendered) {
          lastRendered = t;
          if (isFlipEnabled()) {
            if (flipClockEl) flipClockEl.style.display = '';
            if (plainClockEl) plainClockEl.style.display = 'none';
            renderFlip(t);
          } else {
            if (flipClockEl) flipClockEl.style.display = 'none';
            if (plainClockEl) plainClockEl.style.display = '';
            renderPlain(t);
          }
        }
      }

      function scheduleNextTick() {
        // Align updates to the next second boundary
        const ms = new Date().getMilliseconds();
        const delay = Math.max(0, 1000 - ms + 5);
        realtimeTimeout = setTimeout(() => {
          requestAnimationFrame(() => {
            drawNow();
            scheduleNextTick();
          });
        }, delay);
      }

      function startRealtime() {
        // Pause other timers
        pauseTimerSafely();

        // Hide all non-clock UI via attribute â€” background remains unchanged
        bodyEl.setAttribute('data-mode', 'realtime');

        // Ensure proper clock visibility according to flip setting
        if (isFlipEnabled()) {
          if (flipClockEl) flipClockEl.style.display = '';
          if (plainClockEl) plainClockEl.style.display = 'none';
        } else {
          if (flipClockEl) flipClockEl.style.display = 'none';
          if (plainClockEl) plainClockEl.style.display = '';
        }

        // Reset and launch the loop
        stopRealtime(); // clear any stragglers
        lastRendered = '';
        drawNow();
        scheduleNextTick();
      }

      function stopRealtime() {
        bodyEl.removeAttribute('data-mode');
        if (realtimeTimeout) {
          clearTimeout(realtimeTimeout);
          realtimeTimeout = null;
        }
      }

      function handleFlipToggleDuringRealtime(){
        if (bodyEl.getAttribute('data-mode') !== 'realtime') return;
        lastRendered = ''; // force a redraw on next tick
        drawNow();
      }

      // Wire: time mode changes
      if (timeModeEl) {
        timeModeEl.addEventListener('change', (e) => {
          const mode = e.target.value;
          if (mode === 'realtime') {
            startRealtime();
          } else {
            stopRealtime();
            // Allow existing listeners elsewhere to handle other modes normally
          }
        });
      }

      // Wire: flip style toggle
      if (flipToggle) {
        flipToggle.addEventListener('change', handleFlipToggleDuringRealtime);
      }

      // Safety: pause loop off-tab, resume on return if still in Real Time
      document.addEventListener('visibilitychange', () => {
        if (document.hidden && bodyEl.getAttribute('data-mode') === 'realtime') {
          stopRealtime();
        } else if (!document.hidden && timeModeEl && timeModeEl.value === 'realtime') {
          startRealtime();
        }
      });

      // Optional: if the page loads with "realtime" preselected, start it
      if (timeModeEl && timeModeEl.value === 'realtime') {
        startRealtime();
      }
    })();
  </script>
</body>
</html>
