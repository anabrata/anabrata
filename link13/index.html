<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>QR A4 Arranger (2 cm margins, no login)</title>
<meta name="color-scheme" content="light dark" />
<style>
  :root{
    --bg:#0b1220; --card:#121a2b; --text:#e6eef8; --muted:#92a0b3; --ring:#1f375a; --accent:#0ea5a4;
  }
  @media (prefers-color-scheme: light){
    :root{ --bg:#f6f7fb; --card:#ffffff; --text:#0b1220; --muted:#4a5568; --ring:#d6d9e0; --accent:#0ea5a4 }
  }
  *{ box-sizing:border-box }
  body{ margin:0; font-family:system-ui,Segoe UI,Roboto,Arial,sans-serif; background:var(--bg); color:var(--text) }
  .wrap{ width:min(1000px,94%); margin:2rem auto }
  .card{ background:var(--card); border:1px solid var(--ring); border-radius:12px; padding:1rem }
  h1{ margin:.2rem 0 1rem; font-size:clamp(1.4rem,2.8vw,2rem) }
  .row{ display:flex; gap:.8rem; align-items:center; flex-wrap:wrap }
  .btn{ background:var(--accent); color:#002; border:0; padding:.7rem 1rem; border-radius:.6rem; font-weight:700; cursor:pointer }
  .btn.ghost{ background:transparent; border:1px solid var(--ring); color:var(--text) }
  label,input,button{ font:inherit }
  input[type="number"]{ width:6.5rem }
  .muted{ color:var(--muted) }
  .grid{ display:grid; gap:1rem; grid-template-columns:1fr 1fr }
  @media (max-width: 860px){ .grid{ grid-template-columns:1fr } }
  progress{ width:100% }
  .out{ word-break:break-all; padding:.6rem .7rem; border-radius:.5rem; border:1px dashed var(--ring); background:transparent; color:var(--text) }
  .pill{ display:inline-block; padding:.25rem .5rem; border:1px solid var(--ring); border-radius:999px; font-size:.85rem; color:var(--muted) }
  canvas{ width:100%; background:#fff; border-radius:8px }
  ul.flat { list-style: disc; padding-left: 1.2rem; margin: .4rem 0 0 }
</style>
</head>
<body>
<div class="wrap">
  <h1>QR code arranger (A4 • 2 cm margins • no login)</h1>
  <p class="muted">Upload a ZIP (or images), arrange inside 20 mm margins, auto‑fit to one page, and download a print‑ready PDF.</p>

  <div class="card" style="margin-bottom:1rem">
    <div class="row" style="justify-content:space-between">
      <div class="row">
        <span class="pill">Max per page: 200</span>
        <span class="pill">A4: 210 × 297 mm</span>
        <span class="pill">Margins: 20 mm on all sides</span>
      </div>
    </div>

    <div class="row" style="margin-top:.6rem">
      <input id="files" type="file" accept=".zip,image/*" multiple />
      <button id="arrange" class="btn" type="button">Arrange → PDF</button>
      <a id="downloadPdf" class="btn ghost" download="qr_a4.pdf" href="#" aria-disabled="true">Download PDF</a>
    </div>

    <div class="row" style="margin-top:.6rem">
      <label>QR size (mm): <input id="qrSize" type="number" value="15" step="0.1" min="3"></label>
      <label>Gap (mm): <input id="gap" type="number" value="5" step="0.1" min="0"></label>
      <label><input id="autoFit" type="checkbox" checked> Auto‑fit to one A4 page</label>
    </div>

    <div style="margin-top:.6rem">
      <progress id="prog" value="0" max="100" hidden></progress>
      <div id="note" class="muted" style="margin-top:.4rem"></div>
    </div>
  </div>

  <div class="grid">
    <div class="card">
      <h3>Preview (scaled)</h3>
      <canvas id="preview" width="794" height="1123" aria-label="Preview canvas"></canvas>
      <ul class="muted flat">
        <li>Print the generated PDF at 100% scale. Do not “fit to page”.</li>
        <li>With 15 mm QR + 5 mm gap and 20 mm margins, about 104 fit; Auto‑fit shrinks to fit up to 200.</li>
      </ul>
    </div>
    <div class="card">
      <h3>What it does</h3>
      <ul class="muted flat">
        <li>Reads images from ZIP or file picker (max 200)</li>
        <li>Arranges inside a 20 mm margin on all sides</li>
        <li>Keeps requested size/gap; shrinks if needed to fit on one page</li>
        <li>Outputs a single‑page, millimeter‑accurate A4 PDF</li>
      </ul>
    </div>
  </div>
</div>

<!-- JSZip for reading ZIPs -->
<script src="https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js"></script>
<!-- jsPDF for generating A4 PDF -->
<script src="https://cdn.jsdelivr.net/npm/jspdf@2.5.1/dist/jspdf.umd.min.js"></script>

<script>
// ===== Settings (fixed 20 mm margins) =====
const MARGIN_MM = 20;  // 2 cm from each side
const MAX_IMAGES = 200;

// ===== Elements =====
const $ = id => document.getElementById(id);
const filesEl = $('files');
const arrangeBtn = $('arrange');
const downloadPdf = $('downloadPdf');
const note = $('note');
const prog = $('prog');
const canvas = $('preview');
const ctx = canvas.getContext('2d');
const qrSizeInput = $('qrSize');
const gapInput = $('gap');
const autoFitInput = $('autoFit');

function blobToImage(blob){
  return new Promise((res, rej) => {
    const url = URL.createObjectURL(blob);
    const img = new Image();
    img.onload = () => { URL.revokeObjectURL(url); res(img); };
    img.onerror = rej;
    img.src = url;
  });
}

async function readAllImagesFromInput(fileList){
  const imgs = [];
  const files = Array.from(fileList || []);
  const zips = files.filter(f => f.name.toLowerCase().endsWith('.zip'));
  const singles = files.filter(f => !f.name.toLowerCase().endsWith('.zip'));

  for (const zf of zips){
    const zip = await JSZip.loadAsync(zf);
    const entries = Object.values(zip.files).filter(f => !f.dir && /\.(png|jpe?g|webp|bmp|gif|svg)$/i.test(f.name));
    for (const entry of entries){
      const blob = await entry.async("blob");
      const img = await blobToImage(blob);
      imgs.push(img);
      if (imgs.length >= MAX_IMAGES) break;
    }
    if (imgs.length >= MAX_IMAGES) break;
  }

  for (const f of singles){
    const img = await blobToImage(f);
    imgs.push(img);
    if (imgs.length >= MAX_IMAGES) break;
  }

  return imgs.slice(0, MAX_IMAGES);
}

// Preview layout on canvas (scaled to width)
function previewLayout(imgs, qrMM, gapMM){
  const pageWmm = 210, pageHmm = 297;
  const pxPerMM = canvas.width / pageWmm;

  const pageWpx = Math.round(pageWmm * pxPerMM);
  const pageHpx = Math.round(pageHmm * pxPerMM);
  const marginPx = Math.round(MARGIN_MM * pxPerMM);
  let qrPx = Math.max(1, Math.round(qrMM * pxPerMM));
  let gapPx = Math.max(0, Math.round(gapMM * pxPerMM));

  // Available drawing area within margins
  const availW = pageWpx - 2*marginPx;
  const availH = pageHpx - 2*marginPx;

  function fit(q, g){
    const cols = Math.max(1, Math.floor( (availW + g) / (q + g) ));
    const rows = Math.max(1, Math.floor( (availH + g) / (q + g) ));
    return { cols, rows, capacity: cols*rows };
  }

  let { cols, rows, capacity } = fit(qrPx, gapPx);

  if (capacity < imgs.length && autoFitInput.checked){
    while (capacity < imgs.length && qrPx > 3){
      qrPx -= 1; // shrink 1 px at a time
      ({ cols, rows, capacity } = fit(qrPx, gapPx));
    }
  }

  // White page
  ctx.fillStyle = '#ffffff';
  ctx.fillRect(0, 0, pageWpx, pageHpx);

  // Draw margin guide (optional faint border)
  ctx.strokeStyle = '#d0d0d0';
  ctx.lineWidth = 1;
  ctx.strokeRect(marginPx + 0.5, marginPx + 0.5, availW - 1, availH - 1);

  // Draw images inside margin
  let i = 0;
  for (let r=0; r<rows && i<imgs.length; r++){
    for (let c=0; c<cols && i<imgs.length; c++){
      const x = marginPx + c * (qrPx + gapPx);
      const y = marginPx + r * (qrPx + gapPx);
      ctx.drawImage(imgs[i], x, y, qrPx, qrPx);
      i++;
    }
  }
  return { placed: Math.min(imgs.length, capacity) };
}

function imageToJpegDataURL(img){
  const t = document.createElement('canvas');
  t.width = img.naturalWidth || 512;
  t.height = img.naturalHeight || 512;
  const c = t.getContext('2d');
  c.drawImage(img, 0, 0, t.width, t.height);
  return t.toDataURL('image/jpeg', 0.92);
}

async function buildPdf(imgs, qrMM, gapMM){
  const { jsPDF } = window.jspdf;
  const doc = new jsPDF({ unit: 'mm', format: 'a4' }); // 210 × 297 mm

  const pageW = 210, pageH = 297;
  const availW = pageW - 2*MARGIN_MM;
  const availH = pageH - 2*MARGIN_MM;

  function fit(q, g){
    const cols = Math.max(1, Math.floor( (availW + g) / (q + g) ));
    const rows = Math.max(1, Math.floor( (availH + g) / (q + g) ));
    return { cols, rows, capacity: cols*rows };
  }

  let qr = qrMM, gap = gapMM;
  let { cols, rows, capacity } = fit(qr, gap);

  if (capacity < imgs.length && autoFitInput.checked){
    // shrink until fits or min size reached
    for (let k=0; k<800 && capacity < imgs.length; k++){
      qr = Math.max(3, Math.round((qr - 0.2) * 10) / 10);
      ({ cols, rows, capacity } = fit(qr, gap));
      if (qr <= 3) break;
    }
  }

  // Optional: margin guide (comment out to hide)
  // doc.setDrawColor(220);
  // doc.rect(MARGIN_MM, MARGIN_MM, availW, availH);

  let i = 0;
  for (let r=0; r<rows && i<imgs.length; r++){
    for (let c=0; c<cols && i<imgs.length; c++){
      const x = MARGIN_MM + c * (qr + gap);
      const y = MARGIN_MM + r * (qr + gap);
      const dataUrl = imageToJpegDataURL(imgs[i]);
      doc.addImage(dataUrl, 'JPEG', x, y, qr, qr);
      i++;
    }
  }
  return doc.output('blob');
}

// Arrange → PDF and enable download
arrangeBtn.onclick = async () => {
  try{
    note.textContent = "Reading files…";
    prog.hidden = false; prog.value = 5;
    const imgs = await readAllImagesFromInput(filesEl.files);
    if (!imgs.length){ note.textContent = "No images found."; prog.hidden = true; return; }
    if (imgs.length > MAX_IMAGES) imgs.length = MAX_IMAGES;

    prog.value = 25; note.textContent = `Loaded ${imgs.length} image(s). Arranging…`;

    const qrMM = parseFloat(qrSizeInput.value) || 15;
    const gapMM = parseFloat(gapInput.value) || 5;

    previewLayout(imgs, qrMM, gapMM);

    prog.value = 55; note.textContent = "Building A4 PDF…";
    const blob = await buildPdf(imgs, qrMM, gapMM);

    const url = URL.createObjectURL(blob);
    downloadPdf.href = url;
    downloadPdf.setAttribute('aria-disabled','false');

    prog.value = 100; note.textContent = "PDF ready. Click Download PDF.";
    setTimeout(() => prog.hidden = true, 400);
  } catch(e){
    console.error(e);
    note.textContent = "Error arranging or building PDF.";
    prog.hidden = true;
  }
};
</script>
</body>
</html>
