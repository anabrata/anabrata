<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>WELCOME TO THE WORLD OF SOLAR SYSTEM</title>
<style>
  :root{
    --bg1:#030711; --bg2:#0a1230; --bg3:#0f1c44;
    --orbit:#334469; --orbitFaint:#263250; --label:#e8eefc; --accent:#22d3ee;
    --sun:#ffd966; --mercury:#b9b9b9; --venus:#cdb98f; --earth:#66aaff; --mars:#ff6a5a;
    --jupiter:#d9b38c; --saturn:#f0e0a8; --uranus:#8ce3e8; --neptune:#7ea8ff; --moon:#eeeeee; --ring:#e9d9a6;
  }
  html,body{height:100%}
  *{box-sizing:border-box}
  body{
    margin:0; display:grid; grid-template-rows:auto 1fr auto;
    background: radial-gradient(140% 160% at 15% 10%, var(--bg2) 0%, var(--bg3) 45%, var(--bg1) 100%);
    color:#e5e7eb; font:400 14px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial;
  }
  header{padding:14px 12px; text-align:center}
  .banner{
    display:inline-block; font-weight:900; font-size:28px; letter-spacing:.8px; color:#e2e8f0;
    opacity:0; transform:translateY(14px); animation: fadeIn 2500ms ease-out forwards;
    text-shadow: 0 4px 18px #0008, 0 2px 8px #22d3ee44;
  }
  @keyframes fadeIn{to{opacity:1; transform:translateY(0)}}
  .stage{position:relative}
  canvas{width:100%; height:100%; display:block; outline:none; cursor:grab}
  canvas:active{cursor:grabbing}
  .hud{
    position:absolute; left:12px; right:12px; bottom:12px;
    display:flex; flex-wrap:wrap; gap:10px; align-items:center; justify-content:center;
    background:#0f172acc; border:1px solid #2b3a5a; border-radius:12px; padding:8px 10px; backdrop-filter: blur(8px);
  }
  .hud label{display:flex; gap:6px; align-items:center; font-size:13px}
  .hud input[type=range]{width:180px}
  .hud input[type=checkbox]{accent-color:var(--accent)}
  .lcd{font-variant-numeric: tabular-nums; padding:.25rem .5rem; border:1px solid #2c3a55; border-radius:8px; background:#0b1222a0}
  .badge{font-size:12px; opacity:.9; border:1px solid #334155; border-radius:6px; padding:.2rem .45rem; background:#0b1222a0}
  .legend{position:absolute; top:10px; left:10px; display:flex; gap:10px; flex-wrap:wrap; font-size:12px}
  .legend .dot{width:10px; height:10px; border-radius:50%; display:inline-block}
  .search{
    position:absolute; top:10px; right:10px; display:flex; gap:6px; align-items:center; background:#0f172acc;
    border:1px solid #2b3a5a; border-radius:10px; padding:6px 8px; backdrop-filter: blur(8px);
  }
  .search input{width:180px; padding:6px 8px; border-radius:8px; border:1px solid #2b3a5a; background:#0b1222; color:#e5e7eb; outline:none}
  .search input:focus{border-color:var(--accent)}
  .search button{padding:6px 12px; border-radius:8px; border:1px solid #2b3a5a; background:var(--accent); color:#0b1222; cursor:pointer; font-weight:600; transition:all 0.2s}
  .search button:hover{background:#1dd5ed}
  .panel{
    position:absolute; left:50%; top:6%; transform:translateX(-50%); width:min(720px,95vw);
    background:#0b1222f2; border:1px solid #2b3a5a; border-radius:12px; padding:12px 14px; display:none;
    box-shadow:0 18px 40px #000a; backdrop-filter: blur(8px);
  }
  .panel.open{display:block; animation:panelIn 0.3s ease-out}
  @keyframes panelIn{from{opacity:0; transform:translateX(-50%) translateY(-10px)}}
  .panel h3{margin:0 0 8px; font-size:18px; color:var(--accent)}
  .panel .grid{display:grid; grid-template-columns:1fr 1fr; gap:12px}
  .panel .tag{display:inline-block; padding:.15rem .4rem; border-radius:6px; border:1px solid #2b3a5a; background:#0b1222; margin-right:6px; margin-bottom:4px; font-size:12px}
  .close{position:absolute; right:10px; top:8px; cursor:pointer; color:#cbd5e1; font-size:16px; padding:4px; border-radius:4px; transition:all 0.2s}
  .close:hover{background:#2b3a5a}
  footer{padding:12px; text-align:center; font-weight:700; color:#cbd5e1}
  #err{position:fixed; left:10px; right:10px; bottom:10px; background:#7f1d1d; color:#fee2e2; border:1px solid #fecaca; border-radius:8px; padding:8px 12px; font-size:12px; display:none; z-index:1000}
  .loading{position:absolute; inset:0; display:flex; align-items:center; justify-content:center; background:#030711f0; z-index:999}
  .loading.hidden{display:none}
  .spinner{width:40px; height:40px; border:3px solid #2b3a5a; border-top:3px solid var(--accent); border-radius:50%; animation:spin 1s linear infinite}
  @keyframes spin{to{transform:rotate(360deg)}}
</style>
</head>
<body>
  <header><div class="banner">WELCOME TO THE WORLD OF SOLAR SYSTEM</div></header>
  
  <div class="stage">
    <div class="loading" id="loading">
      <div class="spinner"></div>
    </div>
    
    <canvas id="c"></canvas>
    
    <div class="legend">
      <span><span class="dot" style="background:var(--sun)"></span>Sun</span>
      <span><span class="dot" style="background:var(--earth)"></span>Planets</span>
      <span><span class="dot" style="background:var(--moon)"></span>Moons</span>
    </div>
    
    <div class="search">
      <input id="query" placeholder="Search planet or moon…" />
      <button id="go">Go</button>
    </div>
    
    <div class="hud">
      <label><input type="checkbox" id="realtime" checked> Real‑time</label>
      <label>Speed × <input type="range" id="speed" min="0.1" max="500" step="0.1" value="1"></label>
      <label><input type="checkbox" id="trueScale"> True scale</label>
      <label><input type="checkbox" id="trails"> Trails</label>
      <label><input type="checkbox" id="labels" checked> Labels</label>
      <span class="lcd" id="clock">--:--:-- UTC</span>
      <span class="badge" id="ver">Version: FINAL v4.0.0</span>
    </div>
    
    <div class="panel" id="panel">
      <div class="close" id="close">✕</div>
      <h3 id="pTitle">Celestial Body</h3>
      <div class="grid">
        <div id="pLeft"></div>
        <div id="pRight"></div>
      </div>
    </div>
  </div>
  
  <footer>Made by ANABRATA</footer>
  <div id="err"></div>

  <!-- Three.js core and OrbitControls -->
  <script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.160.0/examples/js/controls/OrbitControls.js"></script>

<script>
(function(){
  'use strict';
  
  // Error handling
  const errBox = document.getElementById('err');
  const loading = document.getElementById('loading');
  window.addEventListener('error', e => {
    errBox.style.display = 'block';
    errBox.textContent = 'Error: ' + (e?.error?.stack || e.message || String(e));
    loading.classList.add('hidden');
  });

  // Initialize Three.js
  const canvas = document.getElementById('c');
  const renderer = new THREE.WebGLRenderer({
    canvas: canvas,
    antialias: true,
    logarithmicDepthBuffer: true,
    powerPreference: 'high-performance'
  });
  
  renderer.outputColorSpace = THREE.SRGBColorSpace;
  renderer.toneMapping = THREE.ACESFilmicToneMapping;
  renderer.toneMappingExposure = 1.2;
  renderer.shadowMap.enabled = true;
  renderer.shadowMap.type = THREE.PCFSoftShadowMap;
  renderer.setPixelRatio(Math.min(window.devicePixelRatio || 1, 2));

  const scene = new THREE.Scene();
  const camera = new THREE.PerspectiveCamera(55, 1, 0.1, 2e7);
  camera.position.set(0, 400, 1000);

  const controls = new THREE.OrbitControls(camera, renderer.domElement);
  controls.enableDamping = true;
  controls.dampingFactor = 0.08;
  controls.minDistance = 50;
  controls.maxDistance = 3e6;
  controls.enablePan = true;
  controls.enableZoom = true;
  controls.enableRotate = true;

  // Responsive sizing
  function resize() {
    const w = canvas.clientWidth || window.innerWidth;
    const h = canvas.clientHeight || window.innerHeight;
    if (canvas.width !== w || canvas.height !== h) {
      renderer.setSize(w, h, false);
      camera.aspect = w / h;
      camera.updateProjectionMatrix();
    }
  }
  new ResizeObserver(resize).observe(canvas);
  window.addEventListener('resize', resize, {passive: true});
  resize();

  // Utility functions
  function css(name) {
    return getComputedStyle(document.documentElement).getPropertyValue(name).trim();
  }

  // Enhanced starfield
  function createStarfield() {
    const geometry = new THREE.BufferGeometry();
    const starCount = 3500;
    const positions = new Float32Array(starCount * 3);
    const colors = new Float32Array(starCount * 3);
    const sizes = new Float32Array(starCount);

    for (let i = 0; i < starCount; i++) {
      const radius = 5000 + Math.random() * 8000;
      const theta = Math.random() * Math.PI * 2;
      const phi = Math.acos(Math.random() * 2 - 1);
      
      positions[i * 3] = Math.sin(phi) * Math.cos(theta) * radius;
      positions[i * 3 + 1] = Math.cos(phi) * radius * 0.3;
      positions[i * 3 + 2] = Math.sin(phi) * Math.sin(theta) * radius;

      const starType = Math.random();
      if (starType < 0.7) {
        colors[i * 3] = colors[i * 3 + 1] = colors[i * 3 + 2] = 1; // White
      } else if (starType < 0.85) {
        colors[i * 3] = 0.6; colors[i * 3 + 1] = 0.8; colors[i * 3 + 2] = 1; // Blue
      } else {
        colors[i * 3] = 1; colors[i * 3 + 1] = 0.8; colors[i * 3 + 2] = 0.6; // Orange
      }

      sizes[i] = Math.random() * 2 + 0.5;
    }

    geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
    geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
    geometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));

    const material = new THREE.PointsMaterial({
      size: 2,
      sizeAttenuation: true,
      vertexColors: true,
      opacity: 0.9,
      transparent: true
    });

    return new THREE.Points(geometry, material);
  }
  scene.add(createStarfield());

  // Enhanced Sun with corona effect
  const sunGeometry = new THREE.SphereGeometry(14, 64, 40);
  const sunMaterial = new THREE.MeshPhysicalMaterial({
    emissive: new THREE.Color(css('--sun')),
    emissiveIntensity: 1.8,
    roughness: 0.6,
    metalness: 0.0,
    color: 0x222222
  });
  const sun = new THREE.Mesh(sunGeometry, sunMaterial);
  scene.add(sun);

  // Enhanced lighting
  const sunlight = new THREE.PointLight(0xffffff, 3.5, 0, 2);
  sunlight.castShadow = true;
  sunlight.shadow.mapSize.width = 2048;
  sunlight.shadow.mapSize.height = 2048;
  scene.add(sunlight);

  const ambientLight = new THREE.AmbientLight(0x404040, 0.1);
  scene.add(ambientLight);

  // Astronomical calculations (Schlyter method)
  const RAD = Math.PI / 180;
  const DEG = 180 / Math.PI;
  const TAU = Math.PI * 2;
  const rev = x => x - Math.floor(x / 360) * 360;

  function julian(date) {
    const y = date.getUTCFullYear();
    const m = date.getUTCMonth() + 1;
    const D = date.getUTCDate();
    const hr = date.getUTCHours();
    const mn = date.getUTCMinutes();
    const sc = date.getUTCSeconds() + date.getUTCMilliseconds() / 1000;
    
    const A = Math.floor((14 - m) / 12);
    const Y = y + 4800 - A;
    const M = m + 12 * A - 3;
    
    const JDN = Math.floor((1461 * Y) / 4) + Math.floor((367 * M) / 12) - 
                Math.floor((3 * Math.floor((Y + 100) / 100)) / 4) + D - 32075;
    
    return JDN + (hr - 12) / 24 + mn / 1440 + sc / 86400;
  }

  function dayNumber(date) {
    return julian(date) - 2451543.5;
  }

  function keplerEllipse(M_deg, e) {
    let E = M_deg + (180 / Math.PI) * e * Math.sin(M_deg * RAD) * (1 + e * Math.cos(M_deg * RAD));
    
    for (let i = 0; i < 4; i++) {
      const E_rad = E * RAD;
      const dE = (E - (180 / Math.PI) * e * Math.sin(E_rad) - M_deg) / (1 - e * Math.cos(E_rad));
      E -= dE;
      if (Math.abs(dE) < 1e-9) break;
    }
    
    const E_rad = E * RAD;
    const xv = Math.cos(E_rad) - e;
    const yv = Math.sqrt(1 - e * e) * Math.sin(E_rad);
    const v = Math.atan2(yv, xv) * DEG;
    const r = Math.sqrt(xv * xv + yv * yv);
    
    return { v, r };
  }

  // Orbital elements (J2000.0 epoch)
  const elements = {
    Mercury: d => ({
      N: 48.3313 + 3.24587e-5 * d,
      i: 7.0047 + 5.0e-8 * d,
      w: 29.1241 + 1.01444e-5 * d,
      a: 0.387098,
      e: 0.205635 + 5.59e-10 * d,
      M: 168.6562 + 4.0923344368 * d
    }),
    Venus: d => ({
      N: 76.6799 + 2.46590e-5 * d,
      i: 3.3946 + 2.75e-8 * d,
      w: 54.8910 + 1.38374e-5 * d,
      a: 0.723330,
      e: 0.006773 - 1.302e-9 * d,
      M: 48.0052 + 1.6021302244 * d
    }),
    Earth: d => ({
      N: 0,
      i: 0,
      w: 282.9404 + 4.70935e-5 * d,
      a: 1.000000,
      e: 0.016709 - 1.151e-9 * d,
      M: 356.0470 + 0.9856002585 * d
    }),
    Mars: d => ({
      N: 49.5574 + 2.11081e-5 * d,
      i: 1.8497 - 1.78e-8 * d,
      w: 286.5016 + 2.92961e-5 * d,
      a: 1.523688,
      e: 0.093405 + 2.516e-9 * d,
      M: 18.6021 + 0.5240207766 * d
    }),
    Jupiter: d => ({
      N: 100.4542 + 2.76854e-5 * d,
      i: 1.3030 - 1.557e-7 * d,
      w: 273.8777 + 1.64505e-5 * d,
      a: 5.20256,
      e: 0.048498 + 4.469e-9 * d,
      M: 19.8950 + 0.0830853001 * d
    }),
    Saturn: d => ({
      N: 113.6634 + 2.38980e-5 * d,
      i: 2.4886 - 1.081e-7 * d,
      w: 339.3939 + 2.97661e-5 * d,
      a: 9.55475,
      e: 0.055546 - 9.499e-9 * d,
      M: 316.9670 + 0.0334442282 * d
    }),
    Uranus: d => ({
      N: 74.0005 + 1.3978e-5 * d,
      i: 0.7733 + 1.9e-8 * d,
      w: 96.6612 + 3.0565e-5 * d,
      a: 19.18171 - 1.55e-8 * d,
      e: 0.047318 + 7.45e-9 * d,
      M: 142.5905 + 0.011725806 * d
    }),
    Neptune: d => ({
      N: 131.7806 + 3.0173e-5 * d,
      i: 1.7700 - 2.55e-7 * d,
      w: 272.8461 - 6.027e-6 * d,
      a: 30.05826 + 3.313e-8 * d,
      e: 0.008606 + 2.15e-9 * d,
      M: 260.2471 + 0.005995147 * d
    })
  };

  function planetHelio(name, d) {
    const el = elements[name](d);
    const kepler = keplerEllipse(rev(el.M), el.e);
    const R = kepler.r * el.a;
    
    const vw = (kepler.v + el.w) * RAD;
    const N = el.N * RAD;
    const i = el.i * RAD;
    
    const x = R * (Math.cos(N) * Math.cos(vw) - Math.sin(N) * Math.sin(vw) * Math.cos(i));
    const y = R * (Math.sin(N) * Math.cos(vw) + Math.cos(N) * Math.sin(vw) * Math.cos(i));
    const z = R * (Math.sin(vw) * Math.sin(i));
    
    return { x, y, z, R, el };
  }

  // Enhanced Moon calculation with perturbations
  function moonHelio(d, earthPos) {
    const N = 125.1228 - 0.0529538083 * d;
    const i = 5.1454;
    const w = 318.0634 + 0.1643573223 * d;
    const a = 60.2666; // Earth radii
    const e = 0.054900;
    const M = 115.3654 + 13.0649929509 * d;
    
    const kepler = keplerEllipse(rev(M), e);
    const r = kepler.r * a;
    
    // Main perturbations
    const sunM = elements.Earth(d).M;
    const sunw = elements.Earth(d).w;
    const Ls = rev(sunM + sunw);
    const Lm = rev(N + w + M);
    const D = rev(Lm - Ls);
    const F = rev(Lm - N);
    
    const lon_corr = -1.274 * Math.sin((M - 2 * D) * RAD) +
                     0.658 * Math.sin((2 * D) * RAD) -
                     0.186 * Math.sin(sunM * RAD) -
                     0.059 * Math.sin((2 * M - 2 * D) * RAD) -
                     0.057 * Math.sin((M - 2 * D + sunM) * RAD) +
                     0.053 * Math.sin((M + 2 * D) * RAD) +
                     0.046 * Math.sin((2 * D - sunM) * RAD) +
                     0.041 * Math.sin((M - sunM) * RAD) -
                     0.035 * Math.sin(D * RAD) -
                     0.031 * Math.sin((M + sunM) * RAD) -
                     0.015 * Math.sin((2 * F - 2 * D) * RAD) +
                     0.011 * Math.sin((M - 4 * D) * RAD);
    
    const lat_corr = -0.173 * Math.sin((F - 2 * D) * RAD) -
                     0.055 * Math.sin((M - F - 2 * D) * RAD) -
                     0.046 * Math.sin((M + F - 2 * D) * RAD) +
                     0.033 * Math.sin((F + 2 * D) * RAD) +
                     0.017 * Math.sin((2 * M + F) * RAD);
    
    const dist_corr = -0.58 * Math.cos((M - 2 * D) * RAD) -
                      0.46 * Math.cos((2 * D) * RAD);
    
    const lon = (kepler.v + w + lon_corr) * RAD;
    const lat = lat_corr * RAD;
    const rr = r + dist_corr;
    
    // Convert to AU
    const AU_KM = 149597870.7;
    const ER_KM = 6378.14;
    const scale = ER_KM / AU_KM;
    
    return {
      x: earthPos.x + rr * Math.cos(lon) * Math.cos(lat) * scale,
      y: earthPos.y + rr * Math.sin(lon) * Math.cos(lat) * scale,
      z: earthPos.z + rr * Math.sin(lat) * scale
    };
  }

  // Scale mapping for visualization
  function createScaleMapper() {
    const minAU = 0.35;
    const maxAU = 32;
    const sceneSpan = 600;
    
    return function(au) {
      const logT = (Math.log10(au) - Math.log10(minAU)) / (Math.log10(maxAU) - Math.log10(minAU));
      return 50 + logT * sceneSpan;
    };
  }
  let mapAU = createScaleMapper();
  addEventListener('resize', () => { mapAU = createScaleMapper(); }, {passive: true});

  // Enhanced materials with better PBR properties
  const materials = {
    Mercury: new THREE.MeshStandardMaterial({
      color: css('--mercury'),
      roughness: 0.9,
      metalness: 0.1
    }),
    Venus: new THREE.MeshStandardMaterial({
      color: css('--venus'),
      roughness: 0.95,
      metalness: 0.05
    }),
    Earth: new THREE.MeshStandardMaterial({
      color: css('--earth'),
      roughness: 0.7,
      metalness: 0.2
    }),
    Mars: new THREE.MeshStandardMaterial({
      color: css('--mars'),
      roughness: 0.85,
      metalness: 0.15
    }),
    Jupiter: new THREE.MeshStandardMaterial({
      color: css('--jupiter'),
      roughness: 0.8,
      metalness: 0.1
    }),
    Saturn: new THREE.MeshStandardMaterial({
      color: css('--saturn'),
      roughness: 0.85,
      metalness: 0.1
    }),
    Uranus: new THREE.MeshStandardMaterial({
      color: css('--uranus'),
      roughness: 0.9,
      metalness: 0.05
    }),
    Neptune: new THREE.MeshStandardMaterial({
      color: css('--neptune'),
      roughness: 0.9,
      metalness: 0.05
    }),
    Moon: new THREE.MeshStandardMaterial({
      color: css('--moon'),
      roughness: 0.95,
      metalness: 0.02
    })
  };

  const ringMaterial = new THREE.MeshStandardMaterial({
    color: css('--ring'),
    side: THREE.DoubleSide,
    transparent: true,
    opacity: 0.7,
    roughness: 0.8
  });

  // Planet sizes (visual and true scale)
  const visualSizes = {
    Mercury: 3.0, Venus: 4.2, Earth: 4.5, Mars: 3.5,
    Jupiter: 11.0, Saturn: 9.5, Uranus: 6.5, Neptune: 6.5, Moon: 1.4
  };
  
  const trueSizesKm = {
    Mercury: 2439.7, Venus: 6051.8, Earth: 6371, Mars: 3389.5,
    Jupiter: 69911, Saturn: 58232, Uranus: 25362, Neptune: 24622, Moon: 1737.4
  };

  const trueScale = document.getElementById('trueScale');
  function getRadius(name) {
    return trueScale.checked ? 
      (trueSizesKm[name] / trueSizesKm.Earth) * visualSizes.Earth : 
      visualSizes[name];
  }

  // Create orbital rings
  function createOrbitRing(radius, faint = false) {
    const geometry = new THREE.RingGeometry(radius - 0.08, radius + 0.08, 256);
    const material = new THREE.MeshBasicMaterial({
      color: faint ? 0x263250 : 0x334469,
      side: THREE.DoubleSide,
      transparent: true,
      opacity: faint ? 0.4 : 0.6
    });
    const ring = new THREE.Mesh(geometry, material);
    ring.rotation.x = Math.PI / 2;
    return ring;
  }

  // Planet creation and management
  const planets = {};
  const orbitRings = {};
  
  function createPlanet(name, isFaint = false) {
    const geometry = new THREE.SphereGeometry(getRadius(name), 64, 40);
    const mesh = new THREE.Mesh(geometry, materials[name]);
    mesh.userData.name = name;
    mesh.userData.type = 'planet';
    mesh.castShadow = true;
    mesh.receiveShadow = true;
    scene.add(mesh);
    planets[name] = mesh;
    
    // Create orbit ring
    const orbitRadius = mapAU(elements[name](0).a);
    const ring = createOrbitRing(orbitRadius, isFaint);
    scene.add(ring);
    orbitRings[name] = ring;
    
    // Add Saturn's rings
    if (name === 'Saturn') {
      const saturnRing = new THREE.Mesh(
        new THREE.RingGeometry(getRadius(name) * 1.4, getRadius(name) * 2.8, 64),
        ringMaterial
      );
      saturnRing.rotation.x = Math.PI / 3;
      mesh.add(saturnRing);
    }
  }

  // Create all planets
  const planetNames = ['Mercury', 'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus', 'Neptune'];
  planetNames.forEach(name => createPlanet(name, name === 'Saturn'));

  // Create Moon
  const moon = new THREE.Mesh(
    new THREE.SphereGeometry(getRadius('Moon'), 48, 32),
    materials.Moon
  );
  moon.userData.name = 'Moon';
  moon.userData.type = 'moon';
  moon.castShadow = true;
  moon.receiveShadow = true;
  scene.add(moon);

  // Galilean moons
  const AU_KM = 149597870.7;
  const galileanData = [
    { name: 'Io', a_km: 421800, period_days: 1.769138, color: 0xffd27d, size: 1.2 },
    { name: 'Europa', a_km: 671100, period_days: 3.551181, color: 0xd6e6ff, size: 1.1 },
    { name: 'Ganymede', a_km: 1070400, period_days: 7.154553, color: 0xe6dcc9, size: 1.4 },
    { name: 'Callisto', a_km: 1882700, period_days: 16.689, color: 0xc9b9a1, size: 1.3 }
  ];
  
  const galileanMoons = galileanData.map(data => {
    const mesh = new THREE.Mesh(
      new THREE.SphereGeometry(data.size, 32, 24),
      new THREE.MeshStandardMaterial({ color: data.color, roughness: 0.95 })
    );
    mesh.userData.name = data.name;
    mesh.userData.type = 'moon';
    mesh.castShadow = true;
    mesh.receiveShadow = true;
    scene.add(mesh);
    return mesh;
  });

  // Label system
  const labels = document.getElementById('labels');
  const labelElements = new Map();
  
  function createLabel(name) {
    if (labelElements.has(name)) return labelElements.get(name);
    
    const element = document.createElement('div');
    element.textContent = name;
    element.style.cssText = `
      position: absolute;
      color: ${css('--label')};
      font: 12px system-ui, Arial;
      pointer-events: none;
      text-shadow: 0 1px 3px #000;
      z-index: 100;
    `;
    document.body.appendChild(element);
    labelElements.set(name, element);
    return element;
  }
  
  function updateLabel(name, object) {
    if (!labels.checked) return;
    
    const vector = object.position.
