<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>World of PDFs • Lossless Watermark Remover • Made by ANABRATA</title>
<meta name="color-scheme" content="light dark" />
<style>
  :root{
    --green:#10b981; --blue:#3b82f6; --yellow:#fde047; --pink:#f9a8d4;
    --card:#ffffffee; --text:#0b1020; --muted:#4b5563; --ring:rgba(0,0,0,.12);
    --grad:linear-gradient(135deg,var(--green),var(--blue),var(--yellow));
  }
  body{
    margin:0; font-family:system-ui,Segoe UI,Roboto,Arial,sans-serif; color:var(--text);
    background:
      radial-gradient(1200px 800px at 10% 10%, rgba(16,185,129,.22), transparent 60%),
      radial-gradient(1200px 800px at 90% 20%, rgba(59,130,246,.22), transparent 60%),
      radial-gradient(1200px 800px at 50% 100%, rgba(253,224,71,.22), transparent 60%),
      linear-gradient(120deg, #e8fdf6, #eef4ff 40%, #fffbe6 80%, #ffffff);
    background-size:140% 140%; animation:bgShift 18s ease-in-out infinite alternate;
  }
  @keyframes bgShift{0%{background-position:0% 0%,100% 0%,50% 100%,0% 0%}100%{background-position:50% 30%,50% 20%,60% 70%,100% 100%}}
  .wrap{ width:min(980px,94%); margin:0 auto; position:relative; z-index:1 }
  header.hero{ min-height:24vh; display:grid; place-items:center; text-align:center; padding: clamp(1.2rem,5vw,2.2rem) 0 1rem; }
  .welcome{
    font-weight:900; letter-spacing:.05em; line-height:1.1;
    background:linear-gradient(90deg, var(--green), var(--blue), var(--yellow), var(--pink), var(--green));
    -webkit-background-clip:text; background-clip:text; color:transparent;
    background-size:220% 100%; animation:hue 14s linear infinite, fadeInOut 8s ease-in-out infinite;
    font-size: clamp(1.1rem, 4.2vw, 2.2rem);
  }
  @keyframes hue{0%{background-position:0% 50%}100%{background-position:220% 50%}}
  @keyframes fadeInOut{0%{opacity:0}18%{opacity:1}82%{opacity:1}100%{opacity:0}}
  .byline{ margin-top:.5rem; font-weight:800; color:#0b1020; display:inline-block; padding:.35rem .7rem; border-radius:.7rem;
           background:linear-gradient(90deg, rgba(16,185,129,.18), rgba(59,130,246,.18), rgba(253,224,71,.18));
           box-shadow:0 6px 22px rgba(16,185,129,.14), 0 4px 16px rgba(59,130,246,.12) }
  .shiny{ position:relative; width:100%; border-radius:18px; padding:1.2rem;
          background:linear-gradient(135deg,rgba(255,255,255,.95),rgba(255,255,255,.90));
          border:1px solid rgba(255,255,255,.7); box-shadow:0 24px 60px rgba(59,130,246,.28),0 16px 40px rgba(16,185,129,.24),inset 0 1px 0 rgba(255,255,255,.7);
          backdrop-filter:blur(12px); overflow:hidden; text-align:center }
  .row{ display:flex; gap:.9rem; align-items:center; flex-wrap:wrap; justify-content:center }
  .btn{ background:var(--grad); color:#073b2b; border:0; padding:.9rem 1.2rem; border-radius:1rem; font-weight:900; cursor:pointer;
        box-shadow:0 8px 22px rgba(16,185,129,.22), 0 4px 14px rgba(59,130,246,.14); font-size:1.02rem }
  .btn.ghost{ background:linear-gradient(135deg, rgba(16,185,129,.12), rgba(59,130,246,.12)); color:#0b1020; border:1px solid var(--ring) }
  .field{ display:flex; align-items:center; gap:.55rem; background:#f8fafc; border:1px solid #e5e7eb; border-radius:.9rem; padding:.55rem .75rem }
  .muted{ color:#4b5563 }
  .panel{ background:var(--card); border:1px solid var(--ring); border-radius:14px; padding:1rem; box-shadow:0 10px 28px rgba(0,0,0,.08); margin-top:1rem }
  progress{ width:100% }
  .list{ text-align:left; margin:.6rem auto 0; max-width:720px }
  .tag{ display:inline-block; margin:.15rem .25rem; padding:.25rem .5rem; border-radius:.6rem; border:1px solid #e5e7eb; background:#fff; font-size:.9rem }
  .info{ text-align:center; color:#111827; opacity:.9; margin:1.2rem 0 2.2rem }
</style>
</head>
<body>
  <header class="hero">
    <div class="wrap">
      <div class="welcome">WELCOME TO THE WORLD OF PDFs</div>
      <div class="byline">Made by ANABRATA</div>
    </div>
  </header>

  <main class="wrap">
    <section class="shiny">
      <div style="font-weight:900; font-size:1.15rem">Lossless background watermark removal</div>
      <div class="muted" style="margin-top:.15rem">No DPI change • No rasterization • Pages stay vector and text. Only watermark objects are removed.</div>
      <div class="row" style="margin-top:.8rem">
        <button class="btn" id="pick">Choose PDF</button>
        <button class="btn ghost" id="scan" disabled>Scan watermarks</button>
        <button class="btn ghost" id="clean" disabled>Remove and download</button>
        <a id="download" class="btn ghost" download="cleaned.pdf" href="#" aria-disabled="true">Download</a>
      </div>
      <input id="file" type="file" accept="application/pdf" hidden>
      <div class="panel">
        <progress id="prog" value="0" max="100" hidden></progress>
        <div id="note" class="muted" style="margin-top:.35rem; min-height:1.2em"></div>
        <div id="findings" class="list"></div>
      </div>
    </section>

    <section class="panel">
      <div style="font-weight:800; margin-bottom:.4rem">What this tool removes (losslessly)</div>
      <div class="muted">
        - Watermark/stamp annotations<br>
        - Optional Content Groups (layers) whose names suggest watermarks (e.g., “Watermark”, “DRAFT”, “CONFIDENTIAL”, “Background”) — removed or hidden<br>
        - Marked-content blocks tagged with /OC … BDC … EMC that reference those layers<br>
        If a PDF has the watermark burned into images, lossless removal is not possible anywhere without re-making those images.
      </div>
    </section>

    <div class="info">© <span id="year"></span> Made by ANABRATA</div>
  </main>

  <!-- pdf-lib for lossless edits -->
  <script src="https://cdn.jsdelivr.net/npm/pdf-lib@1.17.1/dist/pdf-lib.min.js"></script>
  <!-- pako for Flate streams (inflate/deflate) -->
  <script src="https://cdn.jsdelivr.net/npm/pako@2.1.0/dist/pako.min.js"></script>

<script>
document.getElementById('year').textContent = new Date().getFullYear();

const pickBtn = document.getElementById('pick');
const scanBtn = document.getElementById('scan');
const cleanBtn = document.getElementById('clean');
const downloadA = document.getElementById('download');
const fileIn = document.getElementById('file');
const note = document.getElementById('note');
const prog = document.getElementById('prog');
const findingsBox = document.getElementById('findings');

let pdfBytes = null;
let lastScan = null;

pickBtn.onclick = () => fileIn.click();
fileIn.onchange = async () => {
  if (!fileIn.files || !fileIn.files[0]) return;
  pdfBytes = new Uint8Array(await fileIn.files[0].arrayBuffer());
  scanBtn.disabled = false;
  cleanBtn.disabled = false;
  downloadA.setAttribute('aria-disabled','true'); downloadA.removeAttribute('href');
  note.textContent = `Selected: ${fileIn.files[0].name}`;
  findingsBox.innerHTML = '';
};

const NAME_HINTS = ['watermark','draft','confidential','sample','background','bg','test','do not copy'];

scanBtn.onclick = async () => {
  try{
    requirePDF();
    prog.hidden = false; prog.value = 8; note.textContent = "Loading and scanning…";
    const { PDFDocument, PDFName, PDFDict, PDFArray } = PDFLib;
    const doc = await PDFDocument.load(pdfBytes, { updateMetadata:false, ignoreEncryption: false });
    const ctx = doc.context;
    const cat = doc.catalog.dict;

    let ocPropsRef = cat.get(PDFName.of('OCProperties'));
    let ocgNames = [];
    let ocgRefs = [];
    if (ocPropsRef){
      const ocProps = ctx.lookup(ocPropsRef, PDFDict);
      const ocgsArr = ctx.lookup(ocProps.get(PDFName.of('OCGs')), PDFArray);
      for (let i=0;i<ocgsArr.size();i++){
        const ref = ocgsArr.get(i);
        const odict = ctx.lookup(ref, PDFDict);
        const nm = odict.get(PDFName.of('Name'));
        const name = nm ? String(nm.decodeText ? nm.decodeText() : nm.toString()).replace(/^\/?/,'') : '(unnamed)';
        ocgNames.push(name);
        ocgRefs.push({ ref, name });
      }
    }

    // Scan annotations that look like watermarks/stamps
    const pages = doc.getPages();
    let annotCount = 0;
    for (const p of pages){
      const annotsRef = p.node.get(PDFName.of('Annots'));
      if (!annotsRef) continue;
      const arr = ctx.lookup(annotsRef, PDFArray);
      for (let i=0;i<arr.size();i++){
        const aref = arr.get(i);
        const adict = ctx.lookup(aref, PDFDict);
        const subtype = adict.get(PDFName.of('Subtype'));
        const nm = adict.get(PDFName.of('NM')) || adict.get(PDFName.of('Name')) || adict.get(PDFName.of('T'));
        const label = nm ? String(nm.toString()).toLowerCase() : '';
        const kind = subtype ? String(subtype.toString()) : '';
        if (kind === '/Watermark' || kind === '/Stamp' || NAME_HINTS.some(h=>label.includes(h))){
          annotCount++;
        }
      }
    }

    // Guess candidates
    const likely = ocgRefs.filter(o => NAME_HINTS.some(h => o.name.toLowerCase().includes(h)));
    lastScan = { ocgRefs, likely, annotCount };

    findingsBox.innerHTML = '';
    if (ocgRefs.length){
      addFinding(`Layers found: ${ocgRefs.length}`);
      ocgRefs.forEach(o => addTag(o.name));
    } else {
      addFinding('No layers (OCGs) found in catalog.');
    }
    if (likely.length){
      addFinding(`Likely watermark layers:`);
      likely.forEach(o => addTag(o.name));
    }
    if (annotCount){
      addFinding(`Watermark/Stamp annotations detected: ${annotCount}`);
    }
    if (!ocgRefs.length && !annotCount){
      addFinding('Nothing obvious to remove losslessly. If the watermark is baked into images, lossless removal is not possible.');
    }
    prog.value = 100; setTimeout(()=>prog.hidden=true, 300);
    note.textContent = "Scan complete. Click “Remove and download”.";
  } catch(e){
    console.error(e);
    prog.hidden = true;
    note.textContent = "Scan failed: " + (e?.message || e);
  }
};

cleanBtn.onclick = async () => {
  try{
    requirePDF();
    prog.hidden = false; prog.value = 10; note.textContent = "Cleaning (lossless)…";

    const cleaned = await losslessRemoveWatermark(pdfBytes, lastScan);
    const blob = new Blob([cleaned], { type: 'application/pdf' });
    const url = URL.createObjectURL(blob);
    downloadA.href = url;
    downloadA.setAttribute('aria-disabled','false');
    prog.value = 100; setTimeout(()=>prog.hidden=true, 300);
    note.textContent = "Done. Download your cleaned PDF.";
  } catch(e){
    console.error(e);
    prog.hidden = true;
    note.textContent = "Cleaning failed: " + (e?.message || e);
  }
};

/* Helpers */
function addFinding(text){ const p=document.createElement('div'); p.className='muted'; p.textContent=text; findingsBox.appendChild(p); }
function addTag(text){ const s=document.createElement('span'); s.className='tag'; s.textContent=text; findingsBox.appendChild(s); }
function requirePDF(){ if (!pdfBytes) throw new Error('Choose a PDF first'); }

/* Core lossless cleaning */
async function losslessRemoveWatermark(inputBytes, scan){
  const { PDFDocument, PDFName, PDFDict, PDFArray, PDFRawStream } = PDFLib;
  const doc = await PDFDocument.load(inputBytes, { updateMetadata:false, ignoreEncryption:false });
  const ctx = doc.context;
  const cat = doc.catalog.dict;

  // 1) Remove Watermark/Stamp annotations
  let removedAnnots = 0;
  for (const page of doc.getPages()){
    const annotsRef = page.node.get(PDFName.of('Annots'));
    if (!annotsRef) continue;
    const arr = ctx.lookup(annotsRef, PDFArray);
    const kept = [];
    for (let i=0;i<arr.size();i++){
      const aref = arr.get(i);
      const adict = ctx.lookup(aref, PDFDict);
      const subtype = adict.get(PDFName.of('Subtype'));
      const nm = adict.get(PDFName.of('NM')) || adict.get(PDFName.of('Name')) || adict.get(PDFName.of('T'));
      const label = nm ? String(nm.toString()).toLowerCase() : '';
      const kind = subtype ? String(subtype.toString()) : '';
      const looksWM = (kind === '/Watermark') || (kind === '/Stamp') || NAME_HINTS.some(h=>label.includes(h));
      if (looksWM){ removedAnnots++; continue; }
      kept.push(aref);
    }
    if (kept.length !== arr.size()){
      const newArr = PDFArray.withContext(ctx);
      kept.forEach(r => newArr.push(r));
      page.node.set(PDFName.of('Annots'), newArr);
    }
  }

  // 2) Gather OCG layer names we plan to remove/hide
  let ocPropsRef = cat.get(PDFName.of('OCProperties'));
  const toRemoveNames = new Set();
  if (ocPropsRef){
    const ocProps = ctx.lookup(ocPropsRef, PDFDict);
    const ocgsArr = ctx.lookup(ocProps.get(PDFName.of('OCGs')), PDFArray);
    for (let i=0;i<ocgsArr.size();i++){
      const ref = ocgsArr.get(i);
      const odict = ctx.lookup(ref, PDFDict);
      const nm = odict.get(PDFName.of('Name'));
      const name = nm ? String(nm.decodeText ? nm.decodeText() : nm.toString()).replace(/^\/?/,'') : '';
      if (NAME_HINTS.some(h=>name.toLowerCase().includes(h))) toRemoveNames.add(name);
    }

    // Also update default config to turn off these layers
    const D = ocProps.get(PDFName.of('D'));
    if (D){
      const dDict = ctx.lookup(D, PDFDict);
      const offArr = dDict.get(PDFName.of('OFF')) ? ctx.lookup(dDict.get(PDFName.of('OFF')), PDFArray) : PDFArray.withContext(ctx);
      // push all matching OCG refs into OFF
      for (let i=0;i<ocgsArr.size();i++){
        const ref = ocgsArr.get(i);
        const odict = ctx.lookup(ref, PDFDict);
        const nm = odict.get(PDFName.of('Name'));
        const name = nm ? String(nm.decodeText ? nm.decodeText() : nm.toString()).replace(/^\/?/,'') : '';
        if (toRemoveNames.has(name)) offArr.push(ref);
      }
      dDict.set(PDFName.of('OFF'), offArr);
      ocProps.set(PDFName.of('D'), dDict);
      cat.set(PDFName.of('OCProperties'), ocProps);
    }
  }

  // 3) Remove marked-content blocks tagged /OC that reference these OCG names
  if (toRemoveNames.size){
    for (const page of doc.getPages()){
      const contentsRef = page.node.get(PDFName.of('Contents'));
      if (!contentsRef) continue;

      // Normalize to array
      const contentRefs = contentsRef instanceof PDFArray ? contentsRef : (() => { const a=PDFArray.withContext(ctx); a.push(contentsRef); return a; })();

      const newStreams = PDFArray.withContext(ctx);

      for (let ci=0; ci<contentRefs.size(); ci++){
        const sref = contentRefs.get(ci);
        const stream = ctx.lookup(sref, PDFRawStream);
        const dict = stream.dict;
        const filter = dict.get(PDFName.of('Filter'));
        const raw = stream.getContents();

        // Inflate if FlateDecode
        let bytes = raw;
        const fName = filter && String(filter.toString());
        if (fName === '/FlateDecode'){
          bytes = pako.inflate(raw);
        }

        // Decode to string
        const srcStr = new TextDecoder('latin1').decode(bytes);

        // Remove any /OC … BDC … EMC blocks that reference a targeted OCG name in Properties map
        // Strategy:
        //  - Find Properties (Resources/Properties) mapping like /OC1 << /Type /OCG /Name (WATERMARK) >>
        //  - Build map of property name -> OCG name
        //  - Strip content between "/OC /OC1 BDC" ... "EMC" when mapped OCG name is targeted

        // Build property map from page Resources/Properties where available
        let propMap = {};
        const resRef = page.node.get(PDFName.of('Resources'));
        if (resRef){
          const res = ctx.lookup(resRef, PDFDict);
          const propsRef = res.get(PDFName.of('Properties'));
          if (propsRef){
            const props = ctx.lookup(propsRef, PDFDict);
            props.keys().forEach(k => {
              const key = String(k);
              const pRef = props.get(k);
              const pDict = ctx.lookup(pRef, PDFDict);
              const maybeType = pDict.get(PDFName.of('Type'));
              const isOCG = maybeType && String(maybeType.toString()) === '/OCG';
              const nm = pDict.get(PDFName.of('Name'));
              const nmStr = nm ? String(nm.decodeText ? nm.decodeText() : nm.toString()).replace(/^\/?/,'') : '';
              if (isOCG && nmStr) propMap[key] = nmStr;
            });
          }
        }

        // Parser to remove targeted BDC/EMC blocks
        const stripped = stripOCBlocks(srcStr, propMap, toRemoveNames);

        // Re-encode and (re)compress if needed
        let outBytes = new TextEncoder().encode(stripped);
        let outFilter = filter;
        if (fName === '/FlateDecode'){
          outBytes = pako.deflate(outBytes);
          outFilter = PDFName.of('FlateDecode');
        }

        // Create new stream
        const newDict = dict.clone(ctx);
        newDict.set(PDFName.of('Length'), ctx.obj(outBytes.length));
        if (outFilter) newDict.set(PDFName.of('Filter'), outFilter);
        else newDict.delete(PDFName.of('Filter'));
        const newStream = ctx.flateStream ? ctx.flateStream(outBytes, newDict) : ctx.register(new PDFRawStream(newDict, outBytes));
        newStreams.push(newStream);
      }

      // Replace contents
      page.node.set(PDFName.of('Contents'), newStreams);
    }
  }

  // Save unchanged quality
  return await doc.save({ useObjectStreams: true, addDefaultPage: false, updateFieldAppearances: false });
}

/* Strip /OC ... BDC ... EMC for targeted OCGs */
function stripOCBlocks(src, propMap, toRemoveNames){
  // Recognize forms:
  //   /OC /OC1 BDC .... EMC
  //   /OC << /OCGs [..] /Name /Watermark ... >> BDC ... EMC  (rare)
  // We use a conservative parser scanning tokens; remove only when property name resolves to targeted OCG.
  const tokens = src.split(/(\s+)/); // keep whitespace as tokens to preserve spacing
  const out = [];
  let i=0;
  while (i<tokens.length){
    // look for "/OC", ws, "/OCkey", ws, "BDC"
    if (tokens[i] === '/OC'){
      // peek ahead for property name then BDC
      const j = i+2; // skip optional whitespace handled by split keeping spaces
      const maybeName = tokens[i+2] || '';
      const maybeBDC = tokens[i+4] || '';
      if (maybeName.startsWith('/') && maybeBDC.trim() === 'BDC'){
        const propName = maybeName; // e.g. /OC1
        const ocgName = propMap[propName];
        if (ocgName && toRemoveNames.has(ocgName)){
          // skip until matching EMC (balanced nested BDC/EMC)
          let depth = 0;
          i += 5; // move past BDC
          while (i<tokens.length){
            const tk = tokens[i].trim();
            if (tk === 'BDC') depth++;
            if (tk === 'EMC'){
              if (depth===0){ i++; break; }
              depth--;
            }
            i++;
          }
          continue; // removed block
        }
      }
    }
    out.push(tokens[i]);
    i++;
  }
  return out.join('');
}
</script>
</body>
</html>
